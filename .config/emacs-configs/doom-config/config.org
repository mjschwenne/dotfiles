#+filetags: :test: :temp:
#+title: DOOM Emacs Configuration
#+property: header-args:emacs-lisp :tangle config.el

This is my DOOM Emacs configuration. Using DOOM Emacs wasn't my first choice,
I'd rather use a custom or at least more minimal configuration. There is a lot
of things here that I don't exactly think that I need. I am only interested in
Emacs for org mode and Emacs lisp mode (which is of course required for doing
anything in Emacs). I have tried several times to create such a configuration,
but so far I have not been able to create one which is as clean as DOOM Emacs
(which is an unrealistic goal I know) or even functional. My latest attempt
was definitely my best one, but has this weird problem where the org mode
source blocks would not follow correct indentation and (this is the real problem)
hitting ~<return>~ at the end of the last line of such a block would not create a
new line. It just did /nothing/.

That was during the second day of configuring stuff. I searched for hours for a
solution and tried several of them, but was not able to find any. Because of
that, I was back to DOOM Emacs which at least works out of the box which being
/too/ fiddly. It quickly lets me work on the things that I am actually interested in,
creating a powerful note-taking and task management system, but one day I will try
to do back to a completely custom configuration when my Emacs Lisp skills improve.

Let's get started.

The default =config.el= file as a lot of comments with little substance, but I would
still like to preserve it just in case.

* User Information
#+begin_src emacs-lisp
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-

;; Place your private configuration here! Remember, you do not need to run 'doom
;; sync' after modifying this file!


;; Some functionality uses this to identify you, e.g. GPG configuration, email
;; clients, file templates and snippets. It is optional.
(setq user-full-name "Matt Schwennesen"
      user-mail-address "mjschwenne@gmail.com")
#+end_src

* Visuals
** Font Configuration

#+begin_src emacs-lisp
;;; Doom exposes five (optional) variables for controlling fonts in Doom:
;;
;; - `doom-font' -- the primary font to use
;; - `doom-variable-pitch-font' -- a non-monospace font (where applicable)
;; - `doom-big-font' -- used for `doom-big-font-mode'; use this for
;;   presentations or streaming.
;; - `doom-unicode-font' -- for unicode glyphs
;; - `doom-serif-font' -- for the `fixed-pitch-serif' face
;;
;; See 'C-h v doom-font' for documentation and more examples of what they
;; accept. For example:
;;
;;(setq doom-font (font-spec :family "Fira Code" :size 12 :weight 'semi-light)
;;      doom-variable-pitch-font (font-spec :family "Fira Sans" :size 13))
;;
;; If you or Emacs can't find your font, use 'M-x describe-font' to look them
;; up, `M-x eval-region' to execute elisp code, and 'M-x doom/reload-font' to
;; refresh your font settings. If Emacs still can't find your font, it likely
;; wasn't installed correctly. Font issues are rarely Doom issues!

(if (string= system-name "mjs-surface")
    (setq doom-font (font-spec :family "JetBrainsMono Nerd Font" :size 25 :weight 'light))
  (setq doom-font (font-spec :family "JetBrainsMono Nerd Font" :size 15 :weight 'light)))
#+end_src

** Theme

Normally I'd use the Catppuccin theme for everything, but the Catppuccin theme for
Emacs just doesn't look quite right to me, so I'm using my back-up option which is
Tokyo Night.

#+begin_src emacs-lisp
;; There are two ways to load a theme. Both assume the theme is installed and
;; available. You can either set `doom-theme' or manually load a theme with the
;; `load-theme' function. This is the default:
;;(setq doom-theme 'doom-one)
(load-theme 'doom-tokyo-night t)

;;(use-package! autothemer
;;  :ensure t)

;;(load-theme 'catppuccin-mocha t)

;;(set-face-underline 'link t)
;;(custom-theme-set-faces 'catppuccin-mocha
;;                      '(org-block ((t (:background "#181825"))))
;;                       '(org-block-begin-line ((t (:background "#181825" :foreground "#7f849c"))))
;;                       '(org-block-end-line ((t (:background "#181825" :foreground "#7f849c"))))
;;                       '(evil-goggles-default-face ((t (:background "#313244" :extend t)))))

;; Transparency
(set-frame-parameter (selected-frame) 'alpha '(80 . 80))
(add-to-list 'default-frame-alist '(alpha . (80 . 80)))
#+end_src

** Line Numbers

#+begin_src emacs-lisp
;; This determines the style of line numbers in effect. If set to `nil', line
;; numbers are disabled. For relative line numbers, set this to `relative'.
(setq display-line-numbers-type t)
#+end_src

* Keybindings

** Evil

I have been using vim and neovim for about a year and while I still have a lot
to learn about those editors, I've found that even rudimentary knowledge about
their fantastic keybindings in enough to make me an Evil user here in Emacs.
However, I've made some changes in my configuration over here that I'd like to
have here as well.

#+begin_src emacs-lisp
(map! :n "C-h" #'evil-window-left
      :n "C-j" #'evil-window-down
      :n "C-k" #'evil-window-up
      :n "C-l" #'evil-window-right)

; Make evil-snipe search the whole buffer by default
(customize-set-variable 'evil-snipe-scope 'buffer)
(customize-set-variable 'evil-want-C-u-scroll nil)
#+end_src

* Package Configuration

#+begin_src emacs-lisp
;; Whenever you reconfigure a package, make sure to wrap your config in an
;; `after!' block, otherwise Doom's defaults may override your settings. E.g.
;;
;;   (after! PACKAGE
;;     (setq x y))
;;
;; The exceptions to this rule:
;;
;;   - Setting file/directory variables (like `org-directory')
;;   - Setting variables which explicitly tell you to set them before their
;;     package is loaded (see 'C-h v VARIABLE' to look up their documentation).
;;   - Setting doom variables (which start with 'doom-' or '+').
;;
;; Here are some additional functions/macros that will help you configure Doom.
;;
;; - `load!' for loading external *.el files relative to this one
;; - `use-package!' for configuring packages
;; - `after!' for running code after a package has loaded
;; - `add-load-path!' for adding directories to the `load-path', relative to
;;   this file. Emacs searches the `load-path' when you load packages with
;;   `require' or `use-package'.
;; - `map!' for binding new keys
;;
;; To get information about any of these functions/macros, move the cursor over
;; the highlighted symbol at press 'K' (non-evil users must press 'C-c c k').
;; This will open documentation for it, including demos of how they are used.
;; Alternatively, use `C-h o' to look up a symbol (functions, variables, faces,
;; etc).
;;
;; You can also try 'gd' (or 'C-c c d') to jump to their definition and see how
;; they are implemented.
#+end_src

* Org Mode

Start by setting the location of the org files. Also, the catppuccin theme does
not underline org mode links, so add that.

#+begin_src emacs-lisp
;; If you use `org' and don't want your org files in the default location below,
;; change `org-directory'. It must be set before org loads!
(setq org-directory "~/Documents/")
#+end_src

** Built-in Modes

#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'auto-fill-mode)
;; Image previewing in org mode
(customize-set-variable 'org-startup-with-inline-images t)
;; Normally, this would be set with `customize-set-variable`, but DOOM Emacs has a function
;; which is loaded as part of their org initialization which overrides this variable.
;; While I could change that, I want to be able to pull the DOOM repo without issue so
;; I'm using advice to update that value after anytime the function in question is called.
(advice-add '+org-init-appearance-h :after (lambda () (customize-set-variable 'org-image-actual-width '(600))))
#+end_src

** Org Agenda

One of the big reasons why I was interested in Org mode was that it has
first-class support for task management, which is only supported in Obsidian via
a plugin.

#+begin_src emacs-lisp
(setq org-agenda-start-with-log-mode t)
;; Log the time a task is completed in a property drawer.
(setq org-log-done 'time)
(setq org-log-into-drawer t)

(advice-add 'org-refile :after 'org-save-all-org-buffers) ;; Save the buffers after refile

(customize-set-variable 'org-agenda-files (list (concat org-directory "tasks/")))

(customize-set-variable 'org-agenda-custom-commands
                        '(("d" "Daily Schedule"
                          ((agenda ""
                                   ((org-agenda-span 'day)
                                    (org-agenda-use-time-grid nil)
                                    (org-agenda-skip-function '(org-agenda-skip-entry-if 'scheduled 'deadline))))))))
#+end_src

** Structure Templates

Org structure templates are things like the source blocks with Emacs lisp in
them. Be default, Emacs lisp is the only language which works with =org-babel=.
Below I've enabled babel for some other languages that I work with on a regular
basis. I've also added shortcuts for these templates. Particularly for =C=, I
prepended all the shortcuts with "s" to avoid conflicts with existing names.

#+begin_src emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((C . t)
   (cpp . t)
   (emacs-lisp . t)
   (latex . t)
   (python . t)
   (R . t)
   (java . t)))

(require 'org-tempo)
;; There should be a better way to do this, but I haven't found it yet
(add-to-list 'org-structure-template-alist '("sC" . "src C"))
(add-to-list 'org-structure-template-alist '("scpp" . "src cpp"))
(add-to-list 'org-structure-template-alist '("sel" . "src emacs-lisp"))
(add-to-list 'org-structure-template-alist '("sl" . "src latex"))
(add-to-list 'org-structure-template-alist '("spy" . "src python"))
(add-to-list 'org-structure-template-alist '("sR" . "src R"))
(add-to-list 'org-structure-template-alist '("sj" . "src java"))
#+end_src

** Org Capture Templates

Org capture is a great way to quickly create and capture information. Them can
even be populated with automatic information like the date, some common headers,
etc.

However there are no default evil keybindings for finishing the capture. Well,
time to fix that. Also set the header message at the top of the buffer to use
the new keybindings.

#+begin_src emacs-lisp
(map! :map org-capture-map
      :leader
      :prefix ("C" . "Capture")
      :desc "Finsh Capture" :n "f" #'org-capture-finalize
      :desc "Abort Capture" :n "k" #'org-capture-kill
      :desc "Refile Capture" :n "r" #'org-capture-refile)

;; DOOM already modifies the header line to add the target file to the header line.
;; This function is ripped from that with the addition of the `concat' portion which I
;; wrote.
(defun mjs/org-capture-update-header ()
  (setq header-line-format
        (format "%s%s%s"
                (propertize (abbreviate-file-name (buffer-file-name (buffer-base-buffer)))
                                'face 'font-lock-string-face)
                org-eldoc-breadcrumb-separator
                (concat
                 "Capture Buffer. Finish "
                 (propertize "SPC C f" 'face 'help-key-binding)
                 ", refile "
                 (propertize "SPC C r" 'face 'help-key-binding)
                 ", abort "
                 (propertize "SPC C k" 'face 'help-key-binding)
                 " in normal mode."
                 ))))

(advice-add '+org-show-target-in-capture-header-h :override 'mjs/org-capture-update-header)
#+end_src

** Org Appear

This package performs automatic hiding of emphasis markers like Obsidian's live
preview feature. Currently it is not working?

#+begin_src emacs-lisp
(use-package! org-appear
  :config (custom-set-variables '(org-hide-emphasis-markers t)
                                '(org-appear-autolinks t)
                                '(org-appear-trigger 'manual))
  :hook (org-mode . (lambda ()
                       (org-appear-mode t)
                       (add-hook 'evil-insert-state-entry-hook
                                 #'org-appear-manual-start nil t)
                       (add-hook 'evil-insert-state-exit-hook
                                 #'org-appear-manual-stop nil t)))
  )
#+end_src

** Grammar Checking

I am using the =grammar= checker flag built into Doom, but I still have to set
where the =languaguetool= jar is.

#+begin_src emacs-lisp
(setq langtool-language-tool-jar "/home/mjs/.local/share/nvim/site/pack/packer/start/vim-grammarous/misc/LanguageTool-5.9/languagetool-commandline.jar")
(require 'langtool)

#+end_src

** Org Fragtog

This package is similar to =org-appear= but works with LaTeX previews for math
equations. It is currently configured to always preview all LaTeX fragments in a
document upon opening it, and then I have a cheeky method to simulate the manual
mode from =org-appear= for evil insert state hooks. Finally, the exit hook
configuration will preview the current LaTeX fragment if we ~<escape>~ while
inside it.

Below is a test fragment.

$$ \binom{n}{k} = \frac{n!}{k! \times (n-k)!} $$

#+begin_src emacs-lisp
(customize-set-variable 'org-startup-with-latex-preview t)
(add-to-list 'org-latex-packages-alist '("" "sfmath" t))
(add-to-list 'org-latex-packages-alist '("margin=1in" "geometry" t))

(use-package! org-fragtog
 :hook (org-mode . (lambda ()
                     (add-hook 'evil-insert-state-entry-hook (lambda ()
                                                               (when (eq major-mode 'org-mode)
                                                                 (org-fragtog-mode +1))))
                     (add-hook 'evil-insert-state-exit-hook (lambda ()
                                                              (when (eq major-mode 'org-mode)
                                                                (progn
                                                                  (org-fragtog-mode -1)
                                                                  (if (org-inside-LaTeX-fragment-p) (org-latex-preview))))))))
)
#+end_src

** Org Roam
:PROPERTIES:
:ID:       4a713699-1754-49a3-bc4b-fc58dfe70c78
:END:

This is the crux of my note-taking plans and I haven't had time (yet) to get everything
set up for the upcoming semester. As an overview, =org-roam= facilitates the fast linking
and zettlekasten method that Obsidian uses via an sqlite database which it syncs with
the regular org files and maintains. It is named after Roam Research, one of the first
digital zettlekasten tools an inspiration for Obsidian I believe.

#+begin_src emacs-lisp
;; Org-roam settings are directory local variables set for various directory similar to
;; Obsidian vaults.
(setq org-roam-directory org-directory)
(setq org-roam-dailies-directory (concat org-roam-directory "/dailies/"))
(setq org-roam-dailies-capture-templates
      (let ((head
             (concat "#+title: %<%Y-%m-%d (%A)>\n#+startup: showall\n* Daily Overview\n"
                     "#+begin_src emacs-lisp :results value raw\n"
                     "(mjs/get-daily-agenda \"%<%Y-%m-%d>\")\n"
                     "#+end_src\n"
                     "* [/] Do Today\n* [/] Possibly Today\n* Journal\n")))
        `(("j" "journal" entry
           "* %<%H:%M> %?"
           :if-new (file+head+olp "%<%Y-%m-%d>.org" ,head ("Journal")))
          ("t" "do today" item
           "[ ] %a"
           :if-new (file+head+olp "%<%Y-%m-%d>.org" ,head ("Do Today"))
           :immediate-finish t)
          ("m" "possibly today" item
           "[ ] %a"
           :if-new (file+head+olp "%<%Y-%m-%d>.org" ,head ("Possibly Today"))
           :immediate-finish t))))

(add-to-list 'org-capture-templates
             `("s" "Great Basin Session Record" plain
               (file ,(format "%s03-TTRPG/pathfinder/Sessions/great-basin-%s.org"
                             org-directory
                             (org-read-date nil nil "Sun")))
               ,(concat "#+title: Great Basin Session (" (org-read-date nil nil "Sun")
                        ")\n#+date: " (org-read-date nil nil "Sun") "\n"
                        "#+filetags: :session:\n\n")
               :immediate-finish t
               :jump-to-captured t))

(add-hook 'org-capture-mode-hook #'org-id-get-create)

(defun mjs/create-class-note ()
  (interactive)
  (let ((class (completing-read "Class: "
                                '("cs1121" "cs2321" "cs3411" "cs5311" )))
        (buffer (get-buffer-create "Lecture Notes")))
    (set-buffer buffer)
    (insert (concat "#+filetags: " class "\n#+title: " class
                    " (" (format-time-string "%d %B %Y" (current-time)) ")\n"
                    "#+author: Matt Schwennesen\n\n"))
    (write-file (concat org-directory "01-classes/" class "/"
                        (format-time-string "%Y-%m-%d" (current-time)) "-" class ".org"))
    (org-id-get-create)
    (switch-to-buffer buffer)))

(defun mjs/strip-org-roam-links ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward "\\[\\[id:[^]]*\\]\\[\\([^]]*\\)\\]\\]" nil t)
      (progn
        (message "Match detected")
        (replace-match "\\1" nil nil)))
    ))

(defun mjs/org-refile-dwim (target)
  (interactive "FDestination File: \n")
  (unless (org-at-heading-p)
    (error "Point not at org heading! Aborting"))
  (if (file-exists-p target)
      (org-refile nil nil target) ;; File does exist, use regular `org-refile'
    (let ((org-tags (map 'list #'substring-no-properties (org-get-tags)))
          (org-heading (substring-no-properties (org-get-heading)))
          (new-node-id nil)
          (old-buf (current-buffer))
          (new-buf (get-buffer-create (file-name-nondirectory target))))
      (org-copy-subtree nil 'cut)
      (switch-to-buffer new-buf)
      (when org-tags ; Insert tags when then exist
        (insert "#+filetags: ")
        (dolist (tag org-tags)
          (insert (concat ":" tag ": ")))
        (insert "\n"))
      (insert (concat "#+title: " org-heading "\n\n"))
      (write-file target) ; org-roam can only create ids for buffers visiting a file
      (org-id-get-create)
      (setq new-node-id (org-roam-id-at-point))
      (org-paste-subtree)
      (kill-whole-line 2) ; Assumed format is heading followed by blank line
      (org-next-visible-heading 1)
      (when (org-at-heading-p) ; If there is another heading, promote it to first level
        (while (not (eql 1 (nth 0 (org-heading-components))))
          (org-promote-subtree)))
      (goto-char (point-min))
      (write-file target)
      (with-current-buffer old-buf
        (insert (concat "[[id:" new-node-id "][" org-heading "]]\n\n")))
      )))

(map! :map doom-leader-map
      "l" #'mjs/create-class-note)

;; Turn off link completeion everywhere
(setq org-roam-completion-everywhere nil)
;; Make a quick, easy to access keybinding to insert a link with roam
(map! :map org-mode-map
      :i "C-f" #'org-roam-node-insert
      "C-S-f" #'org-insert-link)
#+end_src

*** Integration with Org Agenda

It is possible to pull links to tasks from the agenda into the daily notes and
furthermore it is possible to mark these tasks as complete from the daily note.
Most of this comes from [[https://org-roam.discourse.group/t/daily-task-management-with-org-agenda-and-org-roam-dailies/989/18][this thread on the org-roam discourse]].

#+begin_src emacs-lisp
(defun mjs/toggle-and-mark-done ()
  "Toggle the current checkbox, follow the link under point and mark it as done"
  (interactive)
  (org-toggle-checkbox)
  (org-open-at-point)
  (org-todo 'done))

(map! :map org-mode-map
      :leader
      :localleader
      :prefix ("r" . "roam")
      :desc "Mark Daily Complete" :n "x" #'mjs/toggle-and-mark-done)

(defun mjs/get-daily-agenda (&optional date)
  "Return the agenda for requested day as a string"
  (interactive)
  (let ((file (make-temp-file "daily-agenda" nil ".txt")))
    (org-agenda nil "d" nil)
    (when date (org-agenda-goto-date date))
    (org-agenda-write file nil nil "*Org Agenda*")
    (kill-buffer)
    (with-temp-buffer
      (insert-file-contents file)
      (goto-char (point-min))
      (kill-line 2)
      (while (re-search-forward "^  " nil t)
        (replace-match "- " nil nil))
      (buffer-string))))

(defun mjs/org-roam-make-agenda-link ()
  (interactive)
  (let* ((marker (or (org-get-at-bol 'org-marker)
                     (org-agenda-error)))
         (buffer (marker-buffer marker))
         (pos (marker-position marker)))
    (with-current-buffer buffer
      (save-excursion
        (goto-char pos)
        (org-roam-dailies-capture-today)))))

(map! :map org-agenda-mode-map
      :leader
      :localleader
      :desc "Perform a task Today" :n "t" #'mjs/org-roam-make-agenda-link)
#+end_src


** Vulpea

[[https://github.com/d12frosted/vulpea][Vulpea]] is a package built on top of =org-roam= which extends the database
capabilities of roam. I am particularly interested in it since it can store
metadata while respecting =org= formatting which will simplify things like
tracking locations, etc, in Pathfinder.

#+begin_src emacs-lisp
(use-package! vulpea
  :hook ((org-roam-db-autosync-mode . vulpea-db-autosync-mode)))
#+end_src

** Olivetti Mode

This is a simple mode which centers the text on the screen. I have noticed a few
times that when a new window is opened, the centered text doesn't adjust and
becomes truncated, but this seems to be an intermittent issue and I will
investigate when and if it becomes a larger problem.

#+begin_src emacs-lisp
(use-package! olivetti-mode
  :init (setq olivetti-body-width 100)
  :hook org-mode)
#+end_src

** Transclusions

A transclusion is when instead of just having a link, we display the contents of
that link as well. This is a very powerful feature that I only used occasionally
in Obsidian, but since I have the option of using that same feature via
=org-transclusions=, I might as well use it!

#+begin_src emacs-lisp
(use-package! org-transclusion
  :after org)

(map! :map org-mode-map
      :leader
      :localleader
      :prefix ("u" . "transclusions")
      :desc "Add Transclusion" :n "a" #'org-transclusion-add
      :desc "Activate All Transclusions" :n "u" #'org-transclusion-mode
      :desc "Remove Transclusion" :n "r" #'org-transclusion-remove)
#+end_src

** File Movement

#+begin_src emacs-lisp
(defun mjs/search-org-files (query)
  "Return a list of files in the org directory containing QUERY"
  (split-string
   (shell-command-to-string (format "rg \"%s\" %s" query org-directory))
   ":.*\n" t))

(defun mjs/move-and-update-file-links (source-file dest-dir &optional search-dir)
  "Move SOURCE-FILE to DEST-DIR, updating all org file links in SEARCH-DIR"
    (interactive "fSource File: \nDDestination Directory: \n")
    (let* ((search-dir (if (stringp search-dir) search-dir org-directory))
           (source-file-name (file-name-nondirectory source-file))
           (dest-file (file-name-concat dest-dir source-file-name))
           (file-regexp
            (format
             "\\[\\[\\(file\\|pdf\\):\\([^]:]*%s\\)\\(::[0-9]+\\)?\\]\\[\\([^]]*\\)\\]\\]"
                             source-file-name)))

      (rename-file source-file dest-file t)
      ; Iterate over all files in the search directory referencing the source file
      (dolist (file (mjs/search-org-files source-file-name))
        (with-current-buffer (find-file-noselect file) ; Open that file as a buffer
        ;; Here is where the find and replace can happen
        (let ((relative-dest-file (file-relative-name dest-file
                                                      (file-name-directory file))))
          (message (concat "Searching with: " file-regexp))
          (goto-char (point-min))
          (while (re-search-forward file-regexp nil t)
            (replace-match relative-dest-file nil nil nil 2)
            )
        (save-buffer)
        ))
      )))

(defun mjs/move-dir-update-file-links (source-dir dest-dir &optional search-dir)
  "Move SOURCE-DIR into DEST-DIR, updating all file links in SEARCH-DIR referencing files in SOURCE-DIR"
  (interactive "DSource Directory: \nDDestination Directory: \n")
  (let ((search-dir (if (stringp search-dir) search-dir org-directory))
        (dest-file-base (file-name-concat dest-dir
                                          (file-name-nondirectory
                                           (directory-file-name source-dir)))))
    (dolist (file (directory-files-recursively source-dir ".*"))
      (let ((dest-file-dir (expand-file-name
                            (file-relative-name (file-name-directory file) source-dir)
                            dest-file-base)))
        (unless (file-directory-p dest-file-dir)
          (make-directory dest-file-dir))
        (mjs/move-and-update-file-links file dest-file-dir search-dir)
      ))
    (delete-directory source-dir)
  ))

(defun mjs/regenerate-file-links (src &optional search-dir kill)
  "Regenerate file links in SRC org file by searching SEARCH-DIR and updating file paths"
  (interactive (list (current-buffer)))
  (let* ((search-dir (if (stringp search-dir) search-dir org-directory))
         (src-buf (cond
               ((bufferp src) src)
               ((stringp src) (find-file-noselect src)) ; Assume this is a filename
               (t (current-buffer))))
         (src-file (buffer-file-name src-buf))
         (file-link-regexp
          "\\[\\[\\(file\\|pdf\\):\\([^]:]*\\)\\(::[0-9]+\\)?\\]\\(\\[[^]]*\\]\\)\\]"))
    (with-current-buffer src-buf
      (save-excursion (goto-char (point-min)) ; Move the point to start of buffer
                      (while (re-search-forward file-link-regexp nil t)
                        (let ((rel-dest-file (string-trim (file-relative-name
                                                           (shell-command-to-string
                                                            (format "find %s -name \"%s\""
                                                                    search-dir
                                                                    (file-name-nondirectory
                                                                     (match-string 2))))
                                                           (file-name-directory src-file)))))
                          (replace-match rel-dest-file nil nil nil 2) ; Replace only the file path
                          ))
                      (save-buffer)
                      ))
    (when kill (kill-buffer src-buf))
    ))

(defun mjs/regenerate-file-links-globally (&optional dir)
  (interactive "DDirectory: \n")
  (let ((dir (if (stringp dir) dir org-directory)))
    (dolist (file (directory-files-recursively dir ".*\\.org"))
      (mjs/regenerate-file-links file nil 'kill)
    )
))
#+end_src
