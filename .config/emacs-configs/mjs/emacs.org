#+TITLE: Emacs Configuration
#+PROPTERTY: header-args:emacs-lisp :tangle init.el

* Motivation and Objectives

Using Doom Emacs, as I have for the last year or so, has been great. However,
there are several reasons why I would like to create my own configuration.
1. Doom Emacs is too heavy. I do not need configurations for various programming
   languages or anything more than an extensive =org-mode= configuration.
2. There is a lot of hidden configuration and setup which is inflexible (since I
   can't maintain it) and violates my personal thoughts that my configuration
   should be something completely under my control.

* Table of Contents :TOC_3:
- [[#motivation-and-objectives][Motivation and Objectives]]
- [[#configuration][Configuration]]
  - [[#emacs-setup][Emacs Setup]]
    - [[#identity][Identity]]
    - [[#packages][Packages]]
    - [[#global-emacs-behavior][Global Emacs Behavior]]
  - [[#appearance][Appearance]]
    - [[#menu][Menu]]
    - [[#fonts][Fonts]]
    - [[#cursor-and-current-line][Cursor and Current Line]]
    - [[#theme][Theme]]
    - [[#modeline][Modeline]]
    - [[#gutter][Gutter]]
  - [[#keybindings][Keybindings]]
    - [[#which-key-and-general][Which-key and General]]
    - [[#evil-mode][Evil Mode]]
  - [[#emacs-quality-of-life][Emacs Quality of Life]]
    - [[#helpful][Helpful]]
    - [[#completion][Completion]]
    - [[#other-built-in-modes][Other Built-in Modes]]
  - [[#emacs-lisp-mode][Emacs Lisp Mode]]
  - [[#org-mode][Org Mode]]
    - [[#built-in-modes][Built-in Modes]]
    - [[#org-appear][Org Appear]]
    - [[#olivetti-mode][Olivetti Mode]]
    - [[#flycheck][Flycheck]]
    - [[#spell-checking-with-jinx][Spell Checking with Jinx]]
    - [[#org-appearance][Org Appearance]]
    - [[#org-table-of-contents][Org Table of Contents]]
    - [[#pdf-support][PDF Support]]
    - [[#knowledge-base][Knowledge Base]]
    - [[#transclusions][Transclusions]]

* Configuration

** Emacs Setup
*** Identity

#+BEGIN_SRC emacs-lisp :tangle init.el
  ;; -*- lexical-binding: t; -*-

  (setq user-full-name "Matt Schwennesen"
        user-login-name "matt"
        user-real-login-name "mjs"
        user-mail-address "mjschwenne@gmail.com")
#+END_SRC

*** Packages

I will be using the =use-package= macro with =straight.el= for package
configuration.

I decided to use straight since I tend to agree with it's philosophy that the
user's configuration should be the ultimate source of truth and the functional
user interface. Additionally, the built-in package manager =package.el= will
load all installed packages regardless of if they are mentioned in the
initialization file or even if Emacs is launched with the =-Q= flag.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (setq-default straight-use-package-by-default t)
  (defvar bootstrap-version)
  (let ((bootstrap-file
     (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
    (bootstrap-version 6))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
      (url-retrieve-synchronously
      "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
      'silent 'inhibit-cookies)
    (goto-char (point-max))
    (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  ;; Install use-package
  (straight-use-package 'use-package)
  (eval-when-compile (require 'use-package))
  ;; Configure use-package
  (use-package use-package
           :custom (use-package-verbose t)
                   (use-package-always-defer nil)        ; :defer t by default
                   (use-package-always-ensure t)         ; :ensure t by default
                   (use-package-expand-minimally t)
                   (use-package-compute-statistics t)
                   (use-package-enable-imenu-support t))
#+END_SRC

*** Global Emacs Behavior

#+BEGIN_SRC emacs-lisp :tangle init.el
  (setq-default cursor-in-non-selected-widows nil
                speedbar t
                load-prefer-new t
                make-backup-files nil ; Do not create backup files
                compilation-always-kill t
                compilation-ask-about-save nil
                compilation-scroll-output t
                tab-width 4
                indent-tabs-mode nil
                require-final-newline t
                x-select-enable-clipboard t
                fill-column 80
                initial-scratch-message nil
                inhibit-startup-screen t
                column-number-mode t
                enable-recursive-minibuffers t
                use-dialog-box nil
                scroll-margin 8
                hscroll-margin 8
                scroll-conservatively 101)
#+END_SRC

** Appearance

These code blocks control the appearance of Emacs. 

*** Menu

#+BEGIN_SRC emacs-lisp :tangle init.el
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
#+END_SRC

*** Fonts

While I do not currently use any JetBrains editors (I have in the past), I do
think that there font is awesome. We will use the JetBrains Mono Nerd Font for
this Emacs configuration.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (set-frame-parameter (selected-frame) 'font "JetBrainsMono Nerd Font-12")
  (add-to-list 'default-frame-alist
               '(font . "JetBrainsMono Nerd Font-12"))
#+END_SRC

While Emacs 27+ has harfbuzz enabled by default, we still need a package to get
proper ligature support.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (use-package ligature
    :load-path "path-to-ligature-repo"
    :config
    ;; Enable all JetBrains Mono Nerd Font ligatures in programming modes
    (ligature-set-ligatures 'prog-mode '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
                                         ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
                                         "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
                                         "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
                                         "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
                                         "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
                                         "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
                                         "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
                                         ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
                                         "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
                                         "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
                                         "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
                                         "\\\\" "://"))
    ;; Enable most ligatures in text mode, but not all of them since some can mess with formatting
    ;; in org-mode or markdown documents
    (ligature-set-ligatures 'text-mode '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "||=" "||>"
                                         ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
                                         "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
                                         "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
                                         "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
                                         "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
                                         "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
                                         "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
                                         ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
                                         "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
                                         "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
                                         "?=" "?." "??" ";;" "/*" "/>" "//" "__" "~~" "(*" "*)"
                                         "\\\\" "://"))
    ;; Enables ligature checks globally in all buffers. You can also do it
    ;; per mode with `ligature-mode'.
    (global-ligature-mode t))
#+END_SRC

*** Cursor and Current Line

#+BEGIN_SRC emacs-lisp :tangle init.el
  (when window-system (global-hl-line-mode 1))
#+END_SRC

*** Theme

I'm using the Catppuccin theme for Emacs! The straight recipe took some work to
figure out, but it's now set to clone the Catppuccin repository into a local
repo named =catppuccin-theme=, stored with the rest of the straight packages. We
then set the flavor to Frappe, add it to the list of custom themes and then
enable it.

Also, enable transparency.

#+begin_src emacs-lisp :tangle init.el
  (use-package catppuccin-theme
    :straight (catppuccin-theme
               :type git
               :host github
               :repo "catppuccin/emacs"
               :local-repo "catppuccin-theme")
    :custom (catppuccin-flavor 'frappe)
    :init (add-to-list 'custom-theme-load-path
                       (concat straight-base-dir "catppuccin-theme"))
    :config (load-theme 'catppuccin t))

  (set-frame-parameter (selected-frame) 'alpha '(80 . 80))
  (add-to-list 'default-frame-alist '(alpha . (80 . 80)))
#+end_src

The doom theme pack is also a great set of themes, so I will install them as
well.

#+begin_src emacs-lisp
  (use-package doom-themes
    :config
    ;; Global settings (defaults)
    (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
          doom-themes-enable-italic t) ; if nil, italics is universally disabled
    ; (load-theme 'doom-one t)
    ;; Corrects (and improves) org-mode's native fontification.
    (doom-themes-org-config))
#+end_src

*** Modeline

The default modeline is not... inspiring. But also, I would like to use something
other than doom modeline since it doesn't really work in the terminal. Let's try
simple modeline.

To remove some of the clutter from the mode line, use =diminish= to clean up the minor modes.

Modeline packages I'm aware of:
- =simple-modeline=
- =ocodo-svg-modelines=
- =doom-modeline=

#+BEGIN_SRC emacs-lisp :tangle init.el
  (use-package diminish
    :commands diminish)

  (use-package telephone-line
    :custom telephone-line-lhs
            '((evil . (telephone-line-evil-tag-segment))
              (accent . (telephone-line-process-segment
                         telephone-line-minor-mode-segment))
              (nil . (telephone-line-buffer-segment)))
            telephone-line-rhs
            '((nil . (telephone-line-misc-info-segment
                      telephone-line-atom-encoding-segment))
              (accent . (telephone-line-major-mode-segment))
              (evil . (telephone-line-airline-position-segment)))
    :config
      (set-face-foreground 'telephone-line-evil
                           (alist-get 'base catppuccin-frappe-colors))
      (set-face-background 'telephone-line-evil-normal
                           (alist-get 'blue catppuccin-frappe-colors))
      (set-face-background 'telephone-line-evil-insert
                           (alist-get 'green catppuccin-frappe-colors))
      (set-face-background 'telephone-line-evil-visual
                           (alist-get 'mauve catppuccin-frappe-colors))
      (set-face-background 'telephone-line-evil-emacs
                           (alist-get 'red catppuccin-frappe-colors))
      (set-face-background 'telephone-line-evil-operator
                           (alist-get 'peach catppuccin-frappe-colors))
      (set-face-background 'telephone-line-evil-motion
                           (alist-get 'pink catppuccin-frappe-colors))
      (set-face-attribute 'telephone-line-accent-active t
                          :foreground
                            (alist-get 'text catppuccin-frappe-colors)
                          :background
                            (alist-get 'surface1 catppuccin-frappe-colors))
      (set-face-attribute 'mode-line t
                          :foreground (alist-get 'text catppuccin-frappe-colors)
                          :background (alist-get 'base catppuccin-frappe-colors))
      (telephone-line-mode +1))
#+END_SRC

*** Gutter

Turn on relative line numbers and the vim tilde fringe.

#+BEGIN_SRC emacs-lisp :tangle init.el 
 (setq display-line-numbers-type 'relative
        display-line-numbers-current-absolute t)
  (add-hook 'prog-mode-hook #'display-line-numbers-mode)
  (add-hook 'text-mode-hook #'display-line-numbers-mode)
  (add-hook 'conf-mode-hook #'display-line-numbers-mode)

  (use-package vi-tilde-fringe
    :diminish vi-tilde-fringe-mode
    :config (global-vi-tilde-fringe-mode))
#+END_SRC

** Keybindings

*** Which-key and General

These are two packages designed to help manage keybindings in Emacs.

**** Which-key

Shows a pop-up window with avalibale keybindings.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (use-package which-key
    :diminish which-key-mode
    :config (which-key-mode 1))
#+END_SRC

**** General

#+BEGIN_SRC emacs-lisp :tangle init.el
  (use-package general
    :config (general-evil-setup)
            (general-auto-unbind-keys)
            (general-create-definer mjs-leader-def
              :prefix "SPC"
              :non-normal-prefix "M-SPC")
            (general-create-definer mjs-local-leader-def
              :prefix "SPC m"
              :non-normal-prefix "M-SPC m")
            (general-unbind :states 'insert :keymaps 'global-map "M-SPC"))
#+END_SRC

*** Evil Mode

Maw-haw-haw! Evil mode is the package for vim keybindings in Emacs and as a
historic (and current) neovim user, the set of evil packages is essentaial for me
to have a productive workflow.

There are actually a lot of =evil-= packages out there that I'm using, each one of which
brings more of that modal editing goodness to Emacs.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (use-package evil
    :demand t
    :diminish evil-mode
    :custom (evil-want-keybinding nil)
            (evil-want-integration t)
            (evil-echo-state nil)
    :config (evil-mode 1))

  ;; Make evil search similar to vim
  (evil-select-search-module 'evil-search-module 'evil-search)

  ;; Rebind `universal-argument` to 'C-M-u' since 'C-u' now scrolls the buffer
  (global-set-key (kbd "C-M-u") 'universal-argument)

  ;; Use visual line movements by default
  (evil-global-set-key 'motion "j" 'evil-next-visual-line)
  (evil-global-set-key 'motion "k" 'evil-previous-visual-line)
 #+END_SRC

 Now for the =evil= packages.
 - =evil-org= helps extend vim keybindings to parts of =org-mode= not covered by
   =evil= itself, such as the calendar and agenda.
 - =evil-collection= extends vim keybidings to places like the minibuffer and
   unifies movement keys.
 - =evil-args= adds text motions to argument lists in functions.
 - =evil-easymotion= easily jump without spamming motions
 - =evil-surround= adding markers like '"' around text objects.
 - =evil-embrace= extends =evil-surround= for more arbitary pairs.
 - =evil-escape= return to normal mode with a key-chord.
 - =evil-exchange= swap the places of text objects.
 - =evil-goggles= highlight text as actions are being taken on it.
 - =evil-indent-plus= define text objects of lines of text at the same indentation levels.
 - =evil-lion= provides align operators =gl= and =gL= to align things like
   blocks of variable assignments.
 - =evil-nerd-commenter= quickly comment and uncomment lines of code.
 - =evil-numbers= increment and decrement number literals easily.
 - =evil-quick-diff= fast diff between lines of text.
 - =evil-snipe= character searches based on two characters.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (use-package evil-org
    :after org evil
    :diminish evil-org-mode
    :hook (org-mode . evil-org-mode)
    :config (require 'evil-org-agenda)
            (evil-org-agenda-set-keys))

  (use-package evil-collection
    :after evil
    :diminish evil-collection-unimpaired-mode
    :custom (evil-collection-setup-minibuffer t)
    :config (evil-collection-init))

  (use-package evil-args
    :after evil
    :custom (evil-args-delimiters '(" ")) ; defualt value is '("," ";")
                                          ; may want to investiage major-mode dependent
                                          ; values 
    :general (:keymaps 'evil-inner-text-objects-map "a" 'evil-inner-arg)
             (:keymaps 'evil-outer-text-objects-map "a" 'evil-outer-arg)
             (:states 'normal
                      "L" 'evil-forward-arg
                      "H" 'evil-backwards-arg
                      "K" 'evil-jump-out-args)
             (:states 'motion
                      "L" 'evil-forward-arg
                      "H" 'evil-backwards-arg))

  (use-package evil-easymotion
    :after evil
    :general (:states 'motion "SPC SPC" '(nil :which-key "Easy Motion")
                              "SPC SPC" evilem-map))

  (use-package evil-surround
    :after evil
    :config (global-evil-surround-mode 1))

  (use-package evil-embrace
    :after evil-surround
    :config (add-hook 'org-mode-hook 'embrace-org-mode-hook)
            (evil-embrace-enable-evil-surround-integration))

  (use-package evil-escape
    :after evil
    :diminish evil-escape-mode
    :custom (evil-escape-key-sequence "jk")
    :config (evil-escape-mode))

  (use-package evil-exchange
    :after evil
    :config (evil-exchange-install))

  (use-package evil-goggles
    :after evil
    :diminish evil-goggles-mode
    :config (evil-goggles-mode 1))

  (use-package evil-indent-plus
    :after evil
    :config (evil-indent-plus-default-bindings))

  (use-package evil-lion
    :after evil
    :commands evil-lion-left evil-lion-right
    :general (:states 'normal
                      "g a " #'evil-lion-left
                      "g A " #'evil-lion-right))

  ;; TODO move this from the default keymap to match nvim or vice versa
  (use-package evil-nerd-commenter
    :after evil
    :config (evilnc-default-hotkeys nil t))

  (use-package evil-numbers
    :after evil
    :commands evil-numbers/inc-at-pt evil-numbers/dec-at-pt
    :general (:states '(normal visual)
                      "g -" '("Decrement Number at Point" . evil-numbers/dec-at-pt)
                      "g =" '("Increment Number at Point" . evil-numbers/inc-at-pt)))

  (use-package evil-quick-diff
    :after evil
    :straight (:host github :repo "rgrinberg/evil-quick-diff")
    :config (evil-quick-diff-install))

  (use-package evil-snipe
    :after evil
    :diminish evil-snipe-local-mode
    :custom (evil-snipe-smart-case t)
            (evil-snipe-tab-increment t)
    :config (evil-snipe-mode +1)
            (evil-snipe-override-mode +1))

  (use-package evil-visualstar
    :after evil
    :commands (evil-visualstar/begin-search
               evil-visualstar/begin-search-forward
               evil-visualstar/begin-search-backwards)
    :custom (evil-visualstar/persistent nil)
    :init (evil-define-key* 'visual 'global
            "*" #'evil-visualstar/begin-search-forward
            "#" #'evil-visualstar/begin-search-backward))

  (use-package vimish-fold
    :after evil
    :diminish vimish-fold-mode)

  (use-package evil-vimish-fold
    :after vimish-fold
    :diminish evil-vimish-fold-mode
    :init (setq evil-vimish-fold-target-modes '(prog-mode conf-mode text-mode))
    :config (global-evil-vimish-fold-mode))
#+END_SRC

** Emacs Quality of Life

*** Helpful

#+BEGIN_SRC emacs-lisp :tangle init.el
  (use-package helpful
    :commands (helpful-callable helpful-function helpful-macro helpful-command
               helpful-key helpful-variable helpful-at-point)
    :general (mjs-leader-def :states '(normal insert)
                             "h" '(nil :which-key "Help")
                             "h f" '("Callable" . helpful-callable)
                             "h F" '("Function" . helpful-function)
                             "h t" '("Text (Face)" . describe-face)
                             "h m" '("Mode" . describe-mode)
                             "h M" '("Macro" . helpful-macro)
                             "h x" '("Command" . helpful-command)
                             "h k" '("Key" . helpful-key)
                             "h K" '("Kaymap" . describe-keymap)
                             "h v" '("Variable" . helpful-variable)
                             "h p" '("Thing-at-Point" . helpful-at-point)
                             "h s" '("Symbol" . helpful-symbol)
                             "h q" '("Kill Help Buffers" . helpful-kill-buffers)))
#+END_SRC

*** Completion

There are two forms of completion that need to be configured.

**** Minibuffer Completion

This type of completion shows up when we are interacting with the minibuffer,
like after pressing =M-x= or searching for a variable to get help with.

I will be using the =veritco= set of packages to configure minibuffer completion.

#+BEGIN_SRC emacs-lisp :tangle init.el
    (use-package vertico
      :custom (vertico-resize t)
              (vertico-cycle t)
              (enable-recursive-minibuffers t)
      :init (defun crm-indicator (args)
              (cons (format "[CRM%s] %s"
                            (replace-regexp-in-string
                             "\\`\\[.*?\\*\\|\\[.*?]\\*\\'" ""
                             crm-separator)
                            (car args))
                    (cdr args)))
            (advice-add #'completing-read-multiple :filter-args #'crm-indicator)
            (setq minibuffer-prompt-properties
                  '(read-only t cursor-intangible f face minibuffer-prompt))
            (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
            ;; While my understanding is that this should go in the :config
            ;; section, it doesn't seem to actually cause the mode to be
            ;; properly enabled when called from that section for some reason.
            (vertico-mode)
      :general (:keymaps 'vertico-map
                         "M-RET" #'vertico-exit-input
                         "C-j"   #'vertico-next
                         "C-M-j" #'vertico-next-group
                         "C-k"   #'vertico-previous
                         "C-M-k" #'vertico-previous-group
                         "M-TAB" #'minibuffer-complete
                         "?"     #'minibuffer-completion-help))

    (use-package savehist
      :after vertico
      :config (savehist-mode))

    (use-package marginalia
      :general (:keymaps 'minibuffer-local-map
                         "M-A" #'marginalia-cycle)
      :init (marginalia-mode))

  (use-package nerd-icons-completion
    :config (nerd-icons-completion-mode))

  (use-package orderless
    :ensure t
    :custom (completion-styles '(substring orderless basic))
            (completion-category-overrides '((file (styles basic partial-completion))))) 
#+END_SRC

***** Consult

Provides completing-read functionality for many different types of searches or
navigations.

#+BEGIN_SRC emacs-lisp :tangle init.el
    (use-package consult
      :init (recentf-mode 1)
      :custom (register-preview-function #'consult-register-format)
              (register-preview-delay 0.5)
      :general (mjs-leader-def :states '(normal insert)
                 "c"     '(nil :which-key "Consult")
                 "c b"   '("Buffer" . consult-buffer)
                 "c c"   '("Complex Command" . consult-complex-command)
                 "c e"   '("Compile Error" . consult-compile-error)
                 "c f"   '("Recent Files" . consult-recent-file)
                 "c g"   '(nil :which-key "External Search")
                 "c g g" '("Grep" . consult-grep)
                 "c g r" '("Ripgrep" . consult-ripgrep)
                 "c g f" '("Find" . consult-find)
                 "c g l" '("Locate" . consult-locate)
                 "c h"   '(nil :which-key "Help")
                 "c h i" '("Emacs Info" . consult-info)
                 "c h m" '("UNIX Manual" . consult-man)
                 "c m"   '(nil :which-key "Modes")
                 "c m m" '("Minor Modes" . consult-minor-mode-menu)
                 "c m c" '("Mode Commands" . consult-mode-command)
                 "c M"   '("Macro" . consult-kmacro)
                 "c n"   '(nil :which-key "Navigation")
                 "c n i" '("imenu" . consult-imenu)
                 "c n I" '("Multi-imenu" . consult-imenu-multi)
                 "c n l" '("Goto Line" . consult-goto-line)
                 "c n m" '("Goto Mark" . consult-mark)
                 "c n M" '("Goto Global Mark" . consult-global-mark)
                 "c n o" '("Outline" . consult-outline)
                 "c o"   '(nil :which-key "Org")
                 "c o a" '("Agenda" . consult-org-agenda)
                 "c o h" '("Heading" . consult-org-heading)
                 "c r"   '("Registers" . consult-register)
                 "c s"   '(nil :which-key "Search")
                 "c s l" '("Line" . consult-line)
                 "c s m" '("Multi-buffer line" . consult-line-multi)
                 "c t"   '("Themes" . consult-theme)
                 "c y"   '(nil :which-key "Yank")
                 "c y k" '("Kill Ring" . consult-yank-from-kill-ring)
                 "c y p" '("Pop" . consult-yank-pop)
                 "c y r" '("Replace" . consult-yank-replace))
      :config (advice-add #'register-preview :override #'consult-register-window))

#+END_SRC

***** Embark

Embark is a package which is designed to run a command based on what is neat
point. The command =embark-act= is like a prefix-key for a keymap of actions
relevant to the target at point. The documentation states that you can think
of =embark-act= is a keyboard-based right-click contextual menu.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (use-package embark
    :commands embark-act embark-dwim embark-bindings
    :general (mjs-leader-def :states '(normal insert)
               "a" '("Embark Act"       . embark-act)
               "A" '("Embark DWIM"      . embark-dwim)
               "h e" '("Emark Bindings" . embark-bindings))
    :custom (prefix-help-command #'embark-prefix-help-command)
            (embark-prompter #'embark-completing-read-prompter))
    ; :init (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target))

  (use-package embark-consult
    :hook (embark-collect-mode . consult-preview-at-point-mode))
#+END_SRC

**** Completion at Point

In addition to having a window pop-up when dealing with the mini-buffer, we
can also have completion at point while typing in a buffer.

#+BEGIN_SRC emacs-lisp :tangle init.el
    (use-package corfu
      :custom (corfu-cycle t)
              (completion-cycle-threshold 3)
              (corfu-auto t)
              (corfu-quit-no-match t)
              (corfu-preselect 'prompt)
      :general (:keymaps 'corfu-map
                         "TAB" #'corfu-next
                         [tab] #'corfu-next
                         "S-TAB" #'corfu-previous
                         [backtab] #'corfu-previous)
      :init (global-corfu-mode))

    (use-package cape
      :hook (prog-mode . (lambda ()
                           (add-to-list 'completion-at-point-functions #'cape-keywords)))
            (text-mode . (lambda ()
                           (add-to-list 'completion-at-point-functions #'cape-dict)
                           (add-to-list 'completion-at-point-functions #'cape-dabbrev)))
            (org-mode . (lambda ()
                          (add-to-list 'completion-at-point-functions #'cape-elisp-block)))
      :config (add-to-list 'completion-at-point-functions #'cape-file))

    (use-package company-wordfreq
      :init (add-to-list 'completion-at-point-functions (cape-company-to-capf #'company-wordfreq)))
#+END_SRC

*** Other Built-in Modes

#+begin_src emacs-lisp :tangle init.el
  (global-prettify-symbols-mode +1)
#+end_src

** Emacs Lisp Mode

This Emacs configuration is targeted specifically at extensive writing in
=org-mode= and may be extended to a few other writing focused modes (Like LaTeX).
My primary coding editor is neovim and I have no current intention to replace that.

That being said, it's basically impossible to be configuring Emacs and /not/ writing
some amount of elisp, so we'll definitely want a few packages to help with that.

For heavy lisp editing, I will probably want to configure =lispy= and =lispyville=,
but I don't need those yet so I'm choicing to procrastinate.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (use-package macrostep
    :commands marcostep-expand
    :general (mjs-leader-def :states '(normal insert)
               :keymaps 'emacs-lisp-mode-map
               "e" '("Expand Macro" . macrostep-expand)))

  (use-package elisp-def
    :commands elisp-def
    :general (mjs-leader-def :states '(normal insert)
               :keymaps 'emacs-lisp-mode-map
               "d" '("Find Definition" . elisp-def)))

  (use-package elisp-demos
    :config (advice-add 'helpful-update
                        :after #'elisp-demos-advice-helpful-update))

  (use-package highlight-quoted
    :diminish highlight-quoted-mode
    :hook (emacs-lisp-mode . highlight-quoted-mode))
#+END_SRC

** Org Mode

This is the primary reason why I use Emacs in the first place, so the =org-mode=
configuration should be quite extensive.

For some reason, it would seem that =evil= and =org= aren't the greatest of
friends and this can have some interesting impacts on how =src= blocks are
indented while editing them inside the =org= document directly. Behaviors I've
seem include inserting 2 spaces at the beginning of each line when I hit
=<return>= and hitting =<tab>= having no effect.

The below block makes a solid but not perfect attempt to correct some of these
issues. This code was taken almost directly from DOOM Emacs. The last piece of
the puzzle was setting =tab-always-indent= to =nil=, which ironically fixed the
problem of =<tab>= not always indenting the file. I do believe that there is
more work that can be done here, but for the moment it works well enough to
continue to work on this configuration.

TODO: Fix the 2 space indentation which is reset when =<tab>= is pressed.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (use-package org)

  (defun mjs/org-fix-newline-and-indent (&optional indent _arg _interactive)
    "Mimic `newline-and-indent' in src blocks w/ lang-appropriate indentation."
    (when (and org-src-tab-acts-natively (org-in-src-block-p t))
      (save-window-excursion
        (org-babel-do-in-edit-buffer
         (call-interactively #'indent-for-tab-command)))))

  (advice-add #'org-return :after #'mjs/org-fix-newline-and-indent)

  (defun mjs/org-return (&optional indent arg interactive)
    "Automatically indent when calling `org-return'."
    (interactive)
    (org-return electric-indent-mode))
  (general-define-key :states 'insert :keymaps 'org-mode-map "RET" #'mjs/org-return)

  (setq tab-always-indent nil)
  ;; (setq org-src-preserve-indentation t)
#+END_SRC

*** Built-in Modes

#+BEGIN_SRC emacs-lisp :tangle init.el
  (customize-set-variable 'org-directory "~/Documents/")

  (add-hook 'org-mode-hook 'auto-fill-mode)
  (diminish 'auto-fill-function)
  (customize-set-variable 'org-startup-with-inline-images t)
  (customize-set-variable 'org-image-actual-width '(600))
  (customize-set-variable 'org-startup-align-all-tables t)
  (customize-set-variable 'org-startup-folded 'content)
#+END_SRC

**** Babel

#+BEGIN_SRC emacs-lisp :tangle init.el
  (org-babel-do-load-languages
      'org-babel-load-languages
      '((C . t)
        ;; (cpp . t)
        (emacs-lisp . t)
        (latex . t)
        (python . t)
        (R . t)
        (java . t)))

  (require 'org-tempo)

  ;; There should be a better way to do this, but I haven't found it yet
  (add-to-list 'org-structure-template-alist '("sC" . "src C"))
  ;; (add-to-list 'org-structure-template-alist '("scpp" . "src cpp"))
  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("t" . "src latex"))
  (add-to-list 'org-structure-template-alist '("p" . "src python"))
  (add-to-list 'org-structure-template-alist '("R" . "src R"))
  (add-to-list 'org-structure-template-alist '("j" . "src java"))
#+END_SRC

***** Eros Mode

When working with Emacs Lisp (which is rather frequently), we can use
=eval-last-sexp= to slowly evaluate lisp. Eros displays the result of the
evaluation and displays it as an overlay, rather than printing it to the
mini-buffer.

#+begin_src emacs-lisp :tangle init.el
  (use-package eros
    :after org
    :hook (org-mode . eros-mode))
#+end_src

**** Capture Templates

Update the capture headers to use =evil= keybindings. This is the line of text
which tells you how to save the capture, normally =C-c C-f=, =C-c C-k= and =C-c C-r=
(I think). I've changed those to display the =evil= keybidings defined below.

#+begin_src emacs-lisp :tangle init.el
  (mjs-leader-def :keymaps 'org-capture-mode-map
    "C"   '(nil :which-key "Capture")
    "C f" '("Finish Capture" . org-capture-finalize)
    "C k" '("Abort Capture" . org-capture-kill)
    "C r" '("Refile Capture" . org-capture-refile))

  (defun mjs/org-capture-update-header ()
    (setq header-line-format
          (format "%s%s%s"
                  (propertize (abbreviate-file-name
                               (buffer-file-name (buffer-base-buffer)))
                               'face 'font-lock-string-face)
                  " -> "
                  (concat
                   "Capture Buffer. Finish "
                   (propertize "SPC C f" 'face 'help-key-binding)
                   ", refile "
                   (propertize "SPC C r" 'face 'help-key-binding)
                   ", abort "
                   (propertize "SPC C k" 'face 'help-key-binding)
                   " in normal mode."
                   ))))

  (add-hook 'org-capture-mode-hook #'mjs/org-capture-update-header)
#+end_src

**** LaTeX Fragments

This package is similar to =org-appear= but works with LaTeX previews for math
equations. It is currently configured to always preview all LaTeX fragments in a
document upon opening it, and then I have a cheeky method to simulate the manual
mode from =org-appear= for evil insert state hooks. Finally, the exit hook
configuration will preview the current LaTeX fragment if we ~<escape>~ while
inside it.

Below is a test fragment.

$$ \binom{n}{k} = \frac{n!}{k! \times (n-k)!} $$

#+begin_src emacs-lisp :tangle init.el
  (customize-set-variable 'org-startup-with-latex-preview t)
  (setq org-format-latex-options (plist-put org-format-latex-options :scale 1.5))
  (add-to-list 'org-latex-packages-alist '("" "sfmath" t))
  (add-to-list 'org-latex-packages-alist '("margin=1in" "geometry" t))
  (add-to-list 'org-latex-packages-alist '("" "parskip" t))

  (use-package org-fragtog
   :hook (org-mode . (lambda ()
                       (add-hook 'evil-insert-state-entry-hook
                                 (lambda ()
                                   (when (eq major-mode 'org-mode)
                                     (org-fragtog-mode +1))))
                       (add-hook 'evil-insert-state-exit-hook
                                 (lambda ()
                                   (when (eq major-mode 'org-mode)
                                     (progn
                                       (org-fragtog-mode -1)
                                       (if (org-inside-LaTeX-fragment-p)
                                           (org-latex-preview)))))))))
#+end_src

*** Org Appear

This package performs automatic hiding of emphasis markers like Obsidian's live
preview feature.

#+begin_src emacs-lisp :tangle init.el
  (use-package org-appear
    :after org
    :custom (org-hide-emphasis-markers t)
            (org-appear-autolinks t)
            (org-appear-trigger 'manual)
    :hook (org-mode . (lambda ()
                         (org-appear-mode t)
                         (add-hook 'evil-insert-state-entry-hook
                                   #'org-appear-manual-start nil t)
                         (add-hook 'evil-insert-state-exit-hook
                                   #'org-appear-manual-stop nil t))))
#+end_src

*** Olivetti Mode

This is a simple mode which centers the text on the screen. I have noticed a few
times that when a new window is opened, the centered text doesn't adjust and
becomes truncated, but this seems to be an intermittent issue and I will
investigate when and if it becomes a larger problem.

#+begin_src emacs-lisp :tangle init.el
  (use-package olivetti-mode
    :straight (olivetti :local-repo "olivetti")
    :custom (olivetti-body-width 100)
            (olivetti-lighter " 󰘞")
    :hook org-mode
    :init (diminish 'visual-line-mode))
#+end_src

*** Flycheck

Flycheck is syntax checking package. For =org= mode, I'm going to use it to check
my grammar.

#+begin_src emacs-lisp :tangle init.el
  (use-package flycheck
    :diminish " 󰨮"
    :init (global-flycheck-mode))
#+end_src

**** Flycheck Vale

Vale is an open source grammar check which seems easier to use and configure
than =language-tool=, so let's try it out.

#+begin_src emacs-lisp :tangle init.el
  (use-package flycheck-vale
    :config (flycheck-vale-setup))
#+end_src

*** Spell Checking with Jinx

Jinx is a new-ish Emacs package which only spell-checks the portion of the
buffer which is currently visual.

#+begin_src emacs-lisp :tangle init.el
  (use-package jinx
    :diminish " 󰓆"
    :hook (emacs-startup . global-jinx-mode)
    :general (:states '(normal visual) :keymaps 'jinx-mode-map
                      "z =" #'jinx-correct
                      "Z =" #'jinx-languages)
              (:keymaps 'evil-motion-state-map
                        "[ s" #'jinx-previous
                        "] s" #'jinx-next))
#+end_src

*** Org Appearance

**** Org Superstar

Replace those boring '*' we use for org headlines with exciting Unicode
characters! Also, enable =org-indent-mode= and hide the leading stars.

#+begin_src emacs-lisp :tangle init.el
  (add-hook 'org-mode-hook 'org-indent-mode)
  (add-hook 'org-indent-mode-hook (lambda () (diminish 'org-indent-mode)))
  
  (use-package org-superstar-mode
    :straight (org-superstar :local-repo "org-superstar")
    :after org
    :custom (org-superstar-leading-bullet nil)
            (org-hide-leading-stars t)
    :hook org-mode)
#+end_src

**** Org Fancy Priorities

In a continuation of the theme, we can replace task priorities with fancy
symbols too!

#+begin_src emacs-lisp :tangle init.el
  (use-package org-fancy-priorities
    :diminish org-fancy-priorities-mode
    :after org
    :hook (org-mode . org-fancy-priorities-mode))
#+end_src

# Local Variables:
# jinx-local-words: "Catppuccin Flycheck neovim"
# End:

*** Org Table of Contents

#+begin_src emacs-lisp :tangle init.el
  (use-package toc-org
    :hook (org-mode . toc-org-mode))
#+end_src

*** PDF Support

Most of this configuration is taken from DOOM Emacs.

#+begin_src emacs-lisp :tangle init.el
  (use-package pdf-tools
    :mode ("\\.pdf\\'" . pdf-view-mode)
    :magic ("%PDF" . pdf-view-mode)
    :custom (pdf-view-display-size 'fit-page)
            (pdf-view-use-scaling t)
            (pdf-view-use-imagemagick nil)
    :config
      ;; Silence large file prompts for PDFs
      (defun mjs/suppress-large-file-prompts (fn size op-type filename
                                                 &optional offer-raw)
        (unless (string-match-p "\\.pdf\\'" filename)
          (funcall fn size op-type filename offer-raw)))
      (advice-add #'abort-if-file-too-large :around
                  #'mjs/suppress-large-file-prompts)
      ;; Add message about needing to install the pdf server.
      (defun mjs/install-epdfinfo-message (fn &rest args)
        (if (and (require 'pdf-info nil t)
                 (or (pdf-info-running-p)
                     (ignore-errors (pdf-info-check-epdfinfo) t)))
            (apply fn args)
          (fundamental-mode)
          (message "Viewing PDFs in Emacs requires epdfinfo. Use `M-x pdf-tools-install' to build it")))
      (advice-add #'pdf-view-mode :around #'mjs/install-epdfinfo-message)
      (pdf-tools-install-noverify))

  (use-package saveplace-pdf-view
    :after pdf-view)
#+end_src

**** Org PDF Integration

Provides a custom link type for =org= files. This code block is taken from the
=org-pdftools= README.

#+begin_src emacs-lisp :tangle init.el
    (use-package org-noter
      :config
      ;; Your org-noter config ........
      (require 'org-noter-pdf "~/.config/emacs-configs/mjs/straight/repos/org-pdftools/org-noter-pdftools.el"))

    (use-package org-pdftools
      :hook (org-mode . org-pdftools-setup-link))

    (use-package org-noter-pdftools
      :load-path "straight/repos/org-pdftools/"
      :after org-noter
      :config
      ;; Add a function to ensure precise note is inserted
      (defun org-noter-pdftools-insert-precise-note (&optional toggle-no-questions)
        (interactive "P")
        (org-noter--with-valid-session
         (let ((org-noter-insert-note-no-questions (if toggle-no-questions
                                                       (not org-noter-insert-note-no-questions)
                                                     org-noter-insert-note-no-questions))
               (org-pdftools-use-isearch-link t)
               (org-pdftools-use-freepointer-annot t))
           (org-noter-insert-note (org-noter--get-precise-info)))))

      ;; fix https://github.com/weirdNox/org-noter/pull/93/commits/f8349ae7575e599f375de1be6be2d0d5de4e6cbf
      (defun org-noter-set-start-location (&optional arg)
        "When opening a session with this document, go to the current location.
    With a prefix ARG, remove start location."
        (interactive "P")
        (org-noter--with-valid-session
         (let ((inhibit-read-only t)
               (ast (org-noter--parse-root))
               (location (org-noter--doc-approx-location (when (called-interactively-p 'any) 'interactive))))
           (with-current-buffer (org-noter--session-notes-buffer session)
             (org-with-wide-buffer
              (goto-char (org-element-property :begin ast))
              (if arg
                  (org-entry-delete nil org-noter-property-note-location)
                (org-entry-put nil org-noter-property-note-location
                               (org-noter--pretty-print-location location))))))))
      (with-eval-after-load 'pdf-annot
        (add-hook 'pdf-annot-activate-handler-functions #'org-noter-pdftools-jump-to-note)))
#+end_src

*** Knowledge Base

Most of my knowledge base functionality is done with =org-roam=, but some parts of
my Pathfinder game require =vulpea=, an additional library which extends
=org-roam=.

#+begin_src emacs-lisp :tangle init.el
  (use-package org-roam
    :custom (org-roam-directory (file-truename org-directory))
    :general (mjs-leader-def :states 'normal
               "n" '(nil :which-key "Roam")
               "n b" '("Toggle Roam Buffer" . org-roam-buffer-toggle)
               "n f" '("Find Node" . org-roam-node-find)
               "n g" '("Graph" . org-roam-graph)
               "n i" '("Insert Link" . org-roam-node-insert)
               "n c" '("Roam Capture" . org-roam-capture)
               "n s" '("Roam Sync" . org-roam-db-sync)
               "n d" '("Daily" . org-roam-dailies-capture-today))
    :hook (org-mode . org-roam-db-autosync-mode))

  (use-package vulpea
    :hook (org-roam-db-autosync-mode . vulpea-db-autosync-enable))
#+end_src

*** Transclusions

A transclusion is when instead of just having a link, we display the contents of
that link as well. This is a very powerful feature that I only used occasionally
in Obsidian, but since I have the option of using that same feature via
=org-transclusions=, I might as well use it!

#+begin_src emacs-lisp
  (use-package org-transclusion
    :after org
    :general (mjs-local-leader-def :states 'normal :keymaps 'org-mode-map
               "u" '(nil :which-key "Transclusions")
               "u a" '("Add Transclusion" . org-transclusion-add)
               "u u" '("Activate All Transclusions" . org-transclusion-mode)
               "u r" '("Remove Transclusion" . org-transclusion-remove))
#+end_src

