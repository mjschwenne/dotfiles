#+TITLE: Emacs Configuration
#+PROPTERTY: header-args:emacs-lisp :tangle init.el

* Motivation and Objectives

Using Doom Emacs, as I have for the last year or so, has been great. However,
there are several reasons why I would like to create my own configuration.
1. Doom Emacs is too heavy. I do not need configurations for various programming
   languages or anything more than an extensive =org-mode= configuration.
2. There is a lot of hidden configuration and setup which is inflexible (since I
   can't maintain it) and violates my personal thoughts that my configuration
   should be something completely under my control.

* Table of Contents :TOC_3:
- [[#motivation-and-objectives][Motivation and Objectives]]
- [[#configuration][Configuration]]
  - [[#emacs-setup][Emacs Setup]]
    - [[#identity][Identity]]
    - [[#packages][Packages]]
    - [[#global-emacs-behavior][Global Emacs Behavior]]
  - [[#appearance][Appearance]]
    - [[#menu][Menu]]
    - [[#fonts][Fonts]]
    - [[#cursor-and-current-line][Cursor and Current Line]]
    - [[#theme][Theme]]
    - [[#modeline][Modeline]]
    - [[#gutter][Gutter]]
  - [[#keybindings][Keybindings]]
    - [[#which-key-and-general][Which-key and General]]
    - [[#evil-mode][Evil Mode]]
    - [[#quit-keybindings][Quit Keybindings]]
    - [[#buffer--file-bindings][Buffer & File Bindings]]
    - [[#insert-bindings][Insert Bindings]]
  - [[#emacs-quality-of-life][Emacs Quality of Life]]
    - [[#helpful][Helpful]]
    - [[#completion][Completion]]
    - [[#other-built-in-modes][Other Built-in Modes]]
  - [[#emacs-lisp-mode][Emacs Lisp Mode]]
  - [[#org-mode][Org Mode]]
    - [[#org-keybinds][Org keybinds]]
    - [[#built-in-modes][Built-in Modes]]
    - [[#org-appear][Org Appear]]
    - [[#olivetti-mode][Olivetti Mode]]
    - [[#flycheck][Flycheck]]
    - [[#spell-checking-with-jinx][Spell Checking with Jinx]]
    - [[#org-appearance][Org Appearance]]
    - [[#org-table-of-contents][Org Table of Contents]]
    - [[#pdf-support][PDF Support]]
    - [[#knowledge-base][Knowledge Base]]
    - [[#transclusions][Transclusions]]
    - [[#media-handling][Media Handling]]
    - [[#org-chef][Org Chef!]]
    - [[#exporting-org-documents][Exporting Org Documents]]
    - [[#presentation][Presentation]]

* Configuration

** Emacs Setup
*** Identity

#+BEGIN_SRC emacs-lisp :tangle init.el
  ;; -*- lexical-binding: t; -*-

  (setq user-full-name "Matt Schwennesen"
        user-login-name "matt"
        user-real-login-name "mjs"
        user-mail-address "mjschwenne@gmail.com")
#+END_SRC

*** Packages

I will be using the =use-package= macro with =straight.el= for package
configuration.

I decided to use straight since I tend to agree with it's philosophy that the
user's configuration should be the ultimate source of truth and the functional
user interface. Additionally, the built-in package manager =package.el= will
load all installed packages regardless of if they are mentioned in the
initialization file or even if Emacs is launched with the =-Q= flag.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (setq-default straight-use-package-by-default t)
  (defvar bootstrap-version)
  (let ((bootstrap-file
     (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
    (bootstrap-version 6))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
      (url-retrieve-synchronously
      "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
      'silent 'inhibit-cookies)
    (goto-char (point-max))
    (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  ;; Install use-package
  (straight-use-package 'use-package)
  (eval-when-compile (require 'use-package))
  ;; Configure use-package
  (use-package use-package
           :custom (use-package-verbose t)
                   (use-package-always-defer nil)        ; :defer t by default
                   (use-package-always-ensure t)         ; :ensure t by default
                   (use-package-expand-minimally t)
                   (use-package-compute-statistics t)
                   (use-package-enable-imenu-support t))
#+END_SRC

*** Global Emacs Behavior

#+BEGIN_SRC emacs-lisp :tangle init.el
  (setq-default cursor-in-non-selected-widows nil
                speedbar t
                load-prefer-new t
                make-backup-files nil ; Do not create backup files
                compilation-always-kill t
                compilation-ask-about-save nil
                compilation-scroll-output t
                tab-width 4
                indent-tabs-mode nil
                require-final-newline t
                x-select-enable-clipboard t
                fill-column 80
                initial-scratch-message nil
                inhibit-startup-screen t
                column-number-mode t
                enable-recursive-minibuffers t
                use-dialog-box nil
                scroll-margin 8
                hscroll-margin 8
                scroll-conservatively 101)
#+END_SRC

** Appearance

These code blocks control the appearance of Emacs. 

*** Menu

#+BEGIN_SRC emacs-lisp :tangle init.el
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
#+END_SRC

*** Fonts

While I do not currently use any JetBrains editors (I have in the past), I do
think that there font is awesome. We will use the JetBrains Mono Nerd Font for
this Emacs configuration.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (set-frame-parameter (selected-frame) 'font "JetBrainsMono Nerd Font-12")
  (add-to-list 'default-frame-alist
               '(font . "JetBrainsMono Nerd Font-12"))
#+END_SRC

While Emacs 27+ has harfbuzz enabled by default, we still need a package to get
proper ligature support.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (use-package ligature
    :config
    ;; Enable all JetBrains Mono Nerd Font ligatures in programming modes
    (ligature-set-ligatures 'prog-mode '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
                                         ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
                                         "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
                                         "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
                                         "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
                                         "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
                                         "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
                                         "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
                                         ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
                                         "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
                                         "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
                                         "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
                                         "\\\\" "://"))
    ;; Enable most ligatures in text mode, but not all of them since some can mess with formatting
    ;; in org-mode or markdown documents
    (ligature-set-ligatures 'text-mode '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "||=" "||>"
                                         ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
                                         "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
                                         "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
                                         "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
                                         "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
                                         "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
                                         "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
                                         ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
                                         "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
                                         "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
                                         "?=" "?." "??" ";;" "/*" "/>" "//" "__" "~~" "(*" "*)"
                                         "\\\\" "://"))
    ;; Enables ligature checks globally in all buffers. You can also do it
    ;; per mode with `ligature-mode'.
    (global-ligature-mode t))
#+END_SRC

*** Cursor and Current Line

#+BEGIN_SRC emacs-lisp :tangle init.el
  (when window-system (global-hl-line-mode 1))
#+END_SRC

*** Theme

I'm using the Catppuccin theme for Emacs! The straight recipe took some work to
figure out, but it's now set to clone the Catppuccin repository into a local
repo named =catppuccin-theme=, stored with the rest of the straight packages. We
then set the flavor to Frappe, add it to the list of custom themes and then
enable it.

Also, enable transparency.

#+begin_src emacs-lisp :tangle init.el
  (use-package catppuccin-theme
    :straight (catppuccin-theme
               :type git
               :host github
               :repo "catppuccin/emacs"
               :local-repo "catppuccin-theme")
    :custom (catppuccin-flavor 'frappe)
    :init (add-to-list 'custom-theme-load-path
                       (concat straight-base-dir "catppuccin-theme"))
    :config (load-theme 'catppuccin t))

  (set-frame-parameter (selected-frame) 'alpha '(80 . 80))
  (add-to-list 'default-frame-alist '(alpha . (80 . 80)))
#+end_src

The doom theme pack is also a great set of themes, so I will install them as
well.

#+begin_src emacs-lisp
  (use-package doom-themes
    :config
    ;; Global settings (defaults)
    (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
          doom-themes-enable-italic t) ; if nil, italics is universally disabled
    ; (load-theme 'doom-one t)
    ;; Corrects (and improves) org-mode's native fontification.
    (doom-themes-org-config))
#+end_src

*** Modeline

The default modeline is not... inspiring. But also, I would like to use something
other than doom modeline since it doesn't really work in the terminal. Let's try
simple modeline.

To remove some of the clutter from the mode line, use =diminish= to clean up the minor modes.

Modeline packages I'm aware of:
- =simple-modeline=
- =ocodo-svg-modelines=
- =doom-modeline=

#+BEGIN_SRC emacs-lisp :tangle init.el
  (use-package diminish
    :commands diminish)

  (use-package telephone-line
    :custom telephone-line-lhs
            '((evil . (telephone-line-evil-tag-segment))
              (accent . (telephone-line-process-segment
                         telephone-line-minor-mode-segment))
              (nil . (telephone-line-buffer-segment)))
            telephone-line-rhs
            '((nil . (telephone-line-misc-info-segment
                      telephone-line-atom-encoding-segment))
              (accent . (telephone-line-major-mode-segment))
              (evil . (telephone-line-airline-position-segment)))
    :config
      (set-face-foreground 'telephone-line-evil
                           (alist-get 'base catppuccin-frappe-colors))
      (set-face-background 'telephone-line-evil-normal
                           (alist-get 'blue catppuccin-frappe-colors))
      (set-face-background 'telephone-line-evil-insert
                           (alist-get 'green catppuccin-frappe-colors))
      (set-face-background 'telephone-line-evil-visual
                           (alist-get 'mauve catppuccin-frappe-colors))
      (set-face-background 'telephone-line-evil-emacs
                           (alist-get 'red catppuccin-frappe-colors))
      (set-face-background 'telephone-line-evil-operator
                           (alist-get 'peach catppuccin-frappe-colors))
      (set-face-background 'telephone-line-evil-motion
                           (alist-get 'pink catppuccin-frappe-colors))
      (set-face-attribute 'telephone-line-accent-active t
                          :foreground
                            (alist-get 'text catppuccin-frappe-colors)
                          :background
                            (alist-get 'surface1 catppuccin-frappe-colors))
      (set-face-attribute 'mode-line t
                          :foreground (alist-get 'text catppuccin-frappe-colors)
                          :background (alist-get 'base catppuccin-frappe-colors))
      (telephone-line-mode +1))
#+END_SRC

*** Gutter

Turn on relative line numbers and the vim tilde fringe.

#+BEGIN_SRC emacs-lisp :tangle init.el 
 (setq display-line-numbers-type 'relative
        display-line-numbers-current-absolute t)
  (add-hook 'prog-mode-hook #'display-line-numbers-mode)
  (add-hook 'text-mode-hook #'display-line-numbers-mode)
  (add-hook 'conf-mode-hook #'display-line-numbers-mode)

  (use-package vi-tilde-fringe
    :diminish vi-tilde-fringe-mode
    :config (global-vi-tilde-fringe-mode))
#+END_SRC

** Keybindings

*** Which-key and General

These are two packages designed to help manage keybindings in Emacs.

**** Which-key

Shows a pop-up window with available keybindings.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (use-package which-key
    :diminish which-key-mode
    :config (which-key-mode 1))
#+END_SRC

**** General

#+BEGIN_SRC emacs-lisp :tangle init.el
  (use-package general
    :config (general-evil-setup)
            (general-auto-unbind-keys)
            (general-create-definer mjs-leader-def
              :prefix "SPC"
              :non-normal-prefix "M-SPC"
              :whick-key "Leader")
            (general-create-definer mjs-local-leader-def
              :prefix "SPC m"
              :non-normal-prefix "M-SPC m"
              :whick-key "Local Leader")
            (general-unbind :states 'insert :keymaps 'global-map "M-SPC"))
#+END_SRC

*** Evil Mode

Maw-haw-haw! Evil mode is the package for vim keybindings in Emacs and as a
historic (and current) neovim user, the set of evil packages is essentaial for me
to have a productive workflow.

There are actually a lot of =evil-= packages out there that I'm using, each one of which
brings more of that modal editing goodness to Emacs.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (use-package evil
    :demand t
    :diminish evil-mode
    :custom (evil-want-keybinding nil)
            (evil-want-integration t)
            (evil-cross-lines t)
            (evil-echo-state nil)
    :config (evil-mode 1))

  ;; Make evil search similar to vim
  (evil-select-search-module 'evil-search-module 'evil-search)

  ;; Rebind `universal-argument` to 'C-M-u' since 'C-u' now scrolls the buffer
  (global-set-key (kbd "C-M-u") 'universal-argument)

  ;; Use visual line movements by default
  (evil-global-set-key 'motion "j" 'evil-next-visual-line)
  (evil-global-set-key 'motion "k" 'evil-previous-visual-line)
  (general-define-key :states 'normal :map 'override
                      "C-h" #'evil-window-left
                      "C-j" #'evil-window-down
                      "C-k" #'evil-window-up
                      "C-l" #'evil-window-right)
 #+END_SRC

 Now for the =evil= packages.
 - =evil-org= helps extend vim keybindings to parts of =org-mode= not covered by
   =evil= itself, such as the calendar and agenda.
 - =evil-collection= extends vim keybidings to places like the minibuffer and
   unifies movement keys.
 - =evil-args= adds text motions to argument lists in functions.
 - =evil-easymotion= easily jump without spamming motions
 - =evil-surround= adding markers like '"' around text objects.
 - =evil-embrace= extends =evil-surround= for more arbitary pairs.
 - =evil-escape= return to normal mode with a key-chord.
 - =evil-exchange= swap the places of text objects.
 - =evil-goggles= highlight text as actions are being taken on it.
 - =evil-indent-plus= define text objects of lines of text at the same indentation levels.
 - =evil-lion= provides align operators =gl= and =gL= to align things like
   blocks of variable assignments.
 - =evil-nerd-commenter= quickly comment and uncomment lines of code.
 - =evil-numbers= increment and decrement number literals easily.
 - =evil-quick-diff= fast diff between lines of text.
 - =evil-snipe= character searches based on two characters.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (use-package evil-org
    :after org evil
    :diminish evil-org-mode
    :hook (org-mode . evil-org-mode)
          (org-agenda-mode . (lambda ()
                               (require 'evil-org-agenda)
                               (evil-org-agenda-set-keys))))

  (use-package evil-collection
    :after evil
    :diminish evil-collection-unimpaired-mode
    :custom (evil-collection-setup-minibuffer t)
    :config (evil-collection-init))

  (use-package evil-args
    :after evil
    :custom (evil-args-delimiters '(" ")) ; defualt value is '("," ";")
                                          ; may want to investiage major-mode dependent
                                          ; values 
    :general (:keymaps 'evil-inner-text-objects-map "a" 'evil-inner-arg)
             (:keymaps 'evil-outer-text-objects-map "a" 'evil-outer-arg)
             (:states 'normal
                      "L" 'evil-forward-arg
                      "H" 'evil-backwards-arg
                      "K" 'evil-jump-out-args)
             (:states 'motion
                      "L" 'evil-forward-arg
                      "H" 'evil-backwards-arg))

  (use-package evil-easymotion
    :after evil
    :general (:states 'motion "SPC SPC" '(nil :which-key "Easy Motion")
                              "SPC SPC" evilem-map))

  (use-package evil-surround
    :after evil
    :config (global-evil-surround-mode 1))

  (use-package evil-embrace
    :after evil-surround
    :config (add-hook 'org-mode-hook 'embrace-org-mode-hook)
            (evil-embrace-enable-evil-surround-integration))

  (use-package evil-escape
    :after evil
    :diminish evil-escape-mode
    :custom (evil-escape-key-sequence "jk")
    :config (evil-escape-mode))

  (use-package evil-exchange
    :after evil
    :config (evil-exchange-install))

  (use-package evil-goggles
    :after evil
    :diminish evil-goggles-mode
    :config (evil-goggles-mode 1))

  (use-package evil-indent-plus
    :after evil
    :config (evil-indent-plus-default-bindings))

  (use-package evil-lion
    :after evil
    :commands evil-lion-left evil-lion-right
    :general (:states 'normal
                      "g a " #'evil-lion-left
                      "g A " #'evil-lion-right))

  ;; TODO move this from the default keymap to match nvim or vice versa
  (use-package evil-nerd-commenter
    :after evil
    :config (evilnc-default-hotkeys nil t))

  (use-package evil-numbers
    :after evil
    :commands evil-numbers/inc-at-pt evil-numbers/dec-at-pt
    :general (:states '(normal visual)
                      "g -" '("Decrement Number at Point" . evil-numbers/dec-at-pt)
                      "g =" '("Increment Number at Point" . evil-numbers/inc-at-pt)))

  (use-package evil-quick-diff
    :after evil
    :straight (:host github :repo "rgrinberg/evil-quick-diff")
    :config (evil-quick-diff-install))

  (use-package evil-snipe
    :after evil
    :diminish evil-snipe-local-mode
    :custom (evil-snipe-smart-case t)
            (evil-snipe-tab-increment t)
    :config (evil-snipe-mode +1)
            (evil-snipe-override-mode +1))

  (use-package evil-visualstar
    :after evil
    :commands (evil-visualstar/begin-search
               evil-visualstar/begin-search-forward
               evil-visualstar/begin-search-backwards)
    :custom (evil-visualstar/persistent nil)
    :init (evil-define-key* 'visual 'global
            "*" #'evil-visualstar/begin-search-forward
            "#" #'evil-visualstar/begin-search-backward))

  (use-package vimish-fold
    :after evil
    :diminish vimish-fold-mode)

  (use-package evil-vimish-fold
    :after vimish-fold
    :diminish evil-vimish-fold-mode
    :init (setq evil-vimish-fold-target-modes '(prog-mode conf-mode text-mode))
    :config (global-evil-vimish-fold-mode))
#+END_SRC

*** Quit Keybindings

Keybindings to close and quit things will begin with =<local> q=.

Note that it is possible to have Emacs remember session and resume them using
something like =persp-mode=. I never used those features while I was using DOOM
Emacs so I have not bothered to enable them here.

#+begin_src emacs-lisp :tangle init.el
  (defun mjs/restart-server ()
    "Restart the emacs daemon"
    (interactive)
    (server-force-delete)
    (while (server-running-p)
      (sleep-for 1))
    (server-start))

  (defun mjs/kill-all-buffers (&optional buffer-list interactive)
    "Kill all buffers and close their windows"
    (interactive (list (buffer-list) t))
    (if (null buffer-list)
        (message "No buffers to kill")
      (save-some-buffers)
      (delete-other-windows)
      (when (memq (current-buffer) buffer-list)
        ;; :TODO: replace with switching to dashboard buffer
        (switch-to-buffer (get-scratch-buffer-create)))
      (mapc #'kill-buffer buffer-list)
      (message "Killed %d buffers"
               (- (length buffer-list)
                  (length (cl-remove-if-not #'buffer-live-p buffer-list))))))

  (use-package restart-emacs
    :commands restart-emacs)

  (defun mjs/restart-emacs ()
    (interactive)
    (restart-emacs (list "--with-profile" chemacs-profile-name)))

  (mjs-leader-def :states '(normal insert)
                  "q" '(nil :which-key "Quit")
                  "q d" '("Restart Emacs Server" . mjs/restart-server)
                  "q f" '("Delete Frame" . delete-frame)
                  "q F" '("Clear Current Frame" . mjs/kill-all-buffers)
                  "q K" '("Kill Emacs (and Daemon)" . save-buffers-kill-emacs)
                  ;; "q l" '("Restore Last Session" . )
                  ;; "q L" '("Restore Session from File" . )
                  "q q" '("Quit Emacs" . save-buffers-kill-terminal)
                  "q Q" '("Quit Emacs without Saving" . evil-quit-all-with-error-code)
                  ;; "q r" '("Restart & Restore Emacs" . )
                  "q r" '("Restart Emacs" . mjs/restart-emacs)
                  ;; "q s" '("Quick Save Current Session" . )
                  ;; "q S" '("Save Session to File" . )
                  )

#+end_src

*** Buffer & File Bindings

Buffer keybindings are prefixed with =<leader> b= while file bindings are prefixed
with =<leader> f=.

#+begin_src emacs-lisp :tangle init.el
  (defun mjs/switch-buffer ()
    (interactive)
    (consult-buffer '(consult--source-buffer)))

  (defun mjs/copy-this-file (new-path &optional force-p)
    "Copy the current buffer's file to NEW-PATH then open NEW-PATH.

  If FORCE-P, overwrite the destination file, should it exist, without
  confirmation. FORCE-P can also be invoked with the prefix argument."
    (interactive
     (list (read-file-name "Copy file to: ")
           current-prefix-arg))
    (unless (and buffer-file-name (file-exists-p buffer-file-name))
      (user-error "Buffer is not visiting any file"))
    (let ((old-path (buffer-file-name (buffer-base-buffer)))
          (new-path (expand-file-name new-path)))
      (make-directory (file-name-directory new-path) 't)
      (copy-file old-path new-path (or force-p 1))
      (find-file new-path)
      (message "File copied to %S" (abbreviate-file-name new-path))))

  (defun mjs/delete-this-file (&optional path force-p)
    "Delete PATH and kill any open buffers referencing it.

   If PATH is not specified, use the current buffer's file.

   If FORCE-P, delete without confirmation."
    (interactive
     (list (buffer-file-name (buffer-base-buffer))
           current-prefix-arg))
    ;; :TODO: I think that this can be simpiled quite a bit...
    (let* ((path (or path (buffer-file-name (buffer-base-buffer))))
           (short-path (and path (abbreviate-file-name path))))
      (unless path
        (user-error "Buffer is not visiting any file."))
      (unless (file-exists-p path)
        (error "File doesn't exist: %s" path))
      (unless (or force-p (y-or-n-p (format "Really delete %S?" short-path)))
        (user-error "Aborted"))
      (let* ((buf (current-buffer))
             (windows (get-buffer-window-list buf)))
        (unwind-protect
            (progn (delete-file path t) t)
          (if (file-exists-p path)
              (error "Failed to delete %S" short-path)
            (dolist (window (cl-remove-if-not #'window-live-p windows))
              (with-selected-window window
                ;; In order to prevent the other windows from displaying
                ;; things like Help buffers, limit the possible options
                ;; the window can fall back onto to buffers with files as
                ;; this is the buffers I am activly working on with an
                ;; overwhelming majority.
                (unless (buffer-file-name (window-buffer))
                  (previous-buffer)
                  (unless (buffer-file-name (window-buffer))
                    ;; :TODO: replace with switching to dashboard buffer
                    (switch-to-buffer (get-scratch-buffer-create))))))
            ;; If recentf mode is enabled, pruge the file from the list of
            ;; recent files.
            (when (bound-and-true-p recentf-mode)
              (recentf-remove-if-non-kept path))
            (message "Deleted %S" short-path))))))

  (defun mjs/move-this-file (new-path &optional force-p)
    "Move current buffer's file to NEW-PATH.

  If FORCE-P, overwrite the destination file, should it exist,
  without confirmation. To invoke FORCE-P interactively, call with
  a prefix argument."
    (interactive
     (list (read-file-name "Move file to: ")
           current-prefix-arg))
    (unless (and buffer-file-name (file-exists-p buffer-file-name))
      (user-error "Buffer is not visiting any file."))
    (let ((old-path (buffer-file-name (buffer-base-buffer)))
          (new-path (expand-file-name new-path)))
      (when (directory-name-p new-path)
        (setq new-path (concat new-path (file-name-nondirectory old-path))))
      (make-directory (file-name-directory new-path) 't)
      (rename-file old-path new-path (or force-p 1))
      (set-visited-file-name new-path t t)
      (when (bound-and-true-p recentf-mode)
        (recentf-remove-if-non-kept path))
      (message "File moved to %S" (abbreviate-file-name new-path))))

  (defun mjs/yank-buffer-path (&optional root)
    "Copy the current buffer's path to the kill ring."
    (interactive)
    (if-let (filename (or (buffer-file-name (buffer-base-buffer))
                          (bound-and-true-p list-buffers-directory)))
        (let ((path (abbreviate-file-name
                     (if root
                         (file-relative-name filename root)
                       filename))))
          (kill-new path)
          (if (string= path (car kill-ring))
              (message "Copied path: %s" path)
            (user-error "Could not copy filename in current buffer.")))
      (error "Couldn't find filename in current buffer.")))

  (mjs-leader-def :states '(normal insert) :keymaps 'override
    "b"   '(nil :which-key "Buffer")
    "b b" '("Switch Buffer" . mjs/switch-buffer)
    "b B" '("Switch Buffer (all)" . consult-buffer)
    "b c" '("Clone Buffer" . clone-indirect-buffer)
    "b i" '("ibuffer" . ibuffer)
    "b k" '("Kill Buffer" . kill-current-buffer)
    "b K" '("Kill All Buffers" . mjs/kill-all-buffers)
    "b n" '("Next Buffer" . next-buffer)
    "b ]" '("Next Buffer" . next-buffer)
    "b p" '("Previous Buffer" . previous-buffer)
    "b [" '("Previous Buffer" . previous-buffer)
    "b r" '("Revert Buffer" . revert-buffer)
    "b s" '("Save Buffer" . basic-save-buffer)
    "b S" '("Save All Buffers" . evil-write-all)
    "b z" '("Bury Buffer" . bury-buffer)
    "f"   '(nil :which-key "File")
    "f c" '("Copy this File" . mjs/copy-this-file)
    "f C" '("Open Config" . (lambda ()
                              (interactive)
                              (find-file (concat
                                          user-emacs-directory
                                          "emacs.org"))))
    "f d" '("Delete this File" . mjs/delete-this-file)
    "f D" '("Browse Directory" . dired-at-point)
    "f f" '("Find File" . find-file)
    "f l" '("Locate File" . locate)
    "f m" '("Move this File" . mjs/move-this-file)
    "f p" '("Find File in Config" . (lambda ()
                                      (interactive)
                                      (let ((default-directory
                                              user-emacs-directory))
                                        (call-interactively #'find-file))))
    "f r" '("Recent Files" . consult-recent-file)
    "f s" '("Save File" . save-buffer)
    "f S" '("Save File As" . write-file)
    "f y" '("Yank File Path" . mjs/yank-buffer-path)
    "f Y" '("Yank Relative File Path" . (lambda ()
                                          (mjs/yank-buffer-path
                                           default-director))))
#+end_src

*** Insert Bindings

Starting with =<leader> i=, insert things like Unicode characters.

#+begin_src emacs-lisp :tangle init.el
  (use-package emojify
    :hook (after-init . global-emojify-mode))
  
  (mjs-leader-def :states '(normal insert) :keymaps 'override
    "i"  '(nil :which-key "Insert")
    "i u" '("Character" . insert-char)
    "i r" '("Evil Registers" . evil-show-registers)
    "i e" '("Emoji" . emojify-insert-emoji))
#+end_src

** Emacs Quality of Life

*** Helpful

#+BEGIN_SRC emacs-lisp :tangle init.el
  (use-package helpful
    :commands (helpful-callable helpful-function helpful-macro helpful-command
               helpful-key helpful-variable helpful-at-point)
    :general (mjs-leader-def :states '(normal insert)
                             "h" '(nil :which-key "Help")
                             "h f" '("Callable" . helpful-callable)
                             "h F" '("Function" . helpful-function)
                             "h t" '("Text (Face)" . describe-face)
                             "h m" '("Mode" . describe-mode)
                             "h M" '("Macro" . helpful-macro)
                             "h x" '("Command" . helpful-command)
                             "h k" '("Key" . helpful-key)
                             "h K" '("Kaymap" . describe-keymap)
                             "h v" '("Variable" . helpful-variable)
                             "h p" '("Thing-at-Point" . helpful-at-point)
                             "h s" '("Symbol" . helpful-symbol)
                             "h q" '("Kill Help Buffers" . helpful-kill-buffers)))
#+END_SRC

*** Completion

There are two forms of completion that need to be configured.

**** Minibuffer Completion

This type of completion shows up when we are interacting with the minibuffer,
like after pressing =M-x= or searching for a variable to get help with.

I will be using the =veritco= set of packages to configure minibuffer completion.

#+BEGIN_SRC emacs-lisp :tangle init.el
    (use-package vertico
      :straight (vertico :files (:defaults "extensions/*")
                         :includes (vertico-reverse
                                    vertico-directory))
      :custom (vertico-resize t)
              (vertico-cycle t)
              (enable-recursive-minibuffers t)
      :init (defun crm-indicator (args)
              (cons (format "[CRM%s] %s"
                            (replace-regexp-in-string
                             "\\`\\[.*?\\*\\|\\[.*?]\\*\\'" ""
                             crm-separator)
                            (car args))
                    (cdr args)))
            (advice-add #'completing-read-multiple :filter-args #'crm-indicator)
            (setq minibuffer-prompt-properties
                  '(read-only t cursor-intangible f face minibuffer-prompt))
            (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
            ;; While my understanding is that this should go in the :config
            ;; section, it doesn't seem to actually cause the mode to be
            ;; properly enabled when called from that section for some reason.
            (vertico-mode)
            (vertico-reverse-mode)
      ;; Tidy shadowed file names
      :hook (rfn-eshadow-update-overlay . vertico-directory-tidy)
      :general (:keymaps 'vertico-map
                         "M-RET" #'vertico-exit-input
                         "C-j"   #'vertico-next
                         "C-M-j" #'vertico-next-group
                         "C-k"   #'vertico-previous
                         "C-M-k" #'vertico-previous-group
                         "M-TAB" #'minibuffer-complete
                         ;; More convenient directory navigation commands
                         "RET" #'vertico-directory-enter
                         "DEL" #'vertico-directory-delete-char
                         "M-DEL" #'vertico-directory-delete-word
                         "?"     #'minibuffer-completion-help))

    (use-package savehist
      :after vertico
      :config (savehist-mode))

    (use-package marginalia
      :general (:keymaps 'minibuffer-local-map
                         "M-A" #'marginalia-cycle)
      :init (marginalia-mode))

  (use-package nerd-icons-completion
    :config (nerd-icons-completion-mode))

  (use-package orderless
    :ensure t
    :custom (completion-styles '(substring orderless basic))
            (completion-category-overrides '((file (styles basic partial-completion))))) 
#+END_SRC

***** Consult

Provides completing-read functionality for many different types of searches or
navigations.

#+BEGIN_SRC emacs-lisp :tangle init.el
    (use-package consult
      :init (recentf-mode 1)
      :custom (register-preview-function #'consult-register-format)
              (register-preview-delay 0.5)
      :general (mjs-leader-def :states '(normal insert)
                 "c"     '(nil :which-key "Consult")
                 "c b"   '("Buffer" . consult-buffer)
                 "c c"   '("Complex Command" . consult-complex-command)
                 "c e"   '("Compile Error" . consult-compile-error)
                 "c f"   '("Recent Files" . consult-recent-file)
                 "c g"   '(nil :which-key "External Search")
                 "c g g" '("Grep" . consult-grep)
                 "c g r" '("Ripgrep" . consult-ripgrep)
                 "c g f" '("Find" . consult-find)
                 "c g l" '("Locate" . consult-locate)
                 "c h"   '(nil :which-key "Help")
                 "c h i" '("Emacs Info" . consult-info)
                 "c h m" '("UNIX Manual" . consult-man)
                 "c m"   '(nil :which-key "Modes")
                 "c m m" '("Minor Modes" . consult-minor-mode-menu)
                 "c m c" '("Mode Commands" . consult-mode-command)
                 "c M"   '("Macro" . consult-kmacro)
                 "c n"   '(nil :which-key "Navigation")
                 "c n i" '("imenu" . consult-imenu)
                 "c n I" '("Multi-imenu" . consult-imenu-multi)
                 "c n l" '("Goto Line" . consult-goto-line)
                 "c n m" '("Goto Mark" . consult-mark)
                 "c n M" '("Goto Global Mark" . consult-global-mark)
                 "c n o" '("Outline" . consult-outline)
                 "c o"   '(nil :which-key "Org")
                 "c o a" '("Agenda" . consult-org-agenda)
                 "c o h" '("Heading" . consult-org-heading)
                 "c r"   '("Registers" . consult-register)
                 "c s"   '(nil :which-key "Search")
                 "c s l" '("Line" . consult-line)
                 "c s m" '("Multi-buffer line" . consult-line-multi)
                 "c t"   '("Themes" . consult-theme)
                 "c y"   '(nil :which-key "Yank")
                 "c y k" '("Kill Ring" . consult-yank-from-kill-ring)
                 "c y p" '("Pop" . consult-yank-pop)
                 "c y r" '("Replace" . consult-yank-replace))
      :config (advice-add #'register-preview :override #'consult-register-window))

#+END_SRC

***** Embark

Embark is a package which is designed to run a command based on what is neat
point. The command =embark-act= is like a prefix-key for a keymap of actions
relevant to the target at point. The documentation states that you can think
of =embark-act= is a keyboard-based right-click contextual menu.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (use-package embark
    :commands embark-act embark-dwim embark-bindings
    :general (mjs-leader-def :states '(normal insert)
               "E" '(nil :which-key "Embark")
               "E a" '("Embark Act"       . embark-act)
               "E A" '("Embark DWIM"      . embark-dwim)
               "h e" '("Emark Bindings" . embark-bindings))
    :custom (prefix-help-command #'embark-prefix-help-command)
            (embark-prompter #'embark-completing-read-prompter))
    ; :init (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target))

  (use-package embark-consult
    :hook (embark-collect-mode . consult-preview-at-point-mode))
#+END_SRC

**** Completion at Point

In addition to having a window pop-up when dealing with the mini-buffer, we
can also have completion at point while typing in a buffer.

#+BEGIN_SRC emacs-lisp :tangle init.el
    (use-package corfu
      :custom (corfu-cycle t)
              (completion-cycle-threshold 3)
              (corfu-auto t)
              (corfu-quit-no-match t)
              (corfu-preselect 'prompt)
      :general (:keymaps 'corfu-map
                         "TAB" #'corfu-next
                         [tab] #'corfu-next
                         "S-TAB" #'corfu-previous
                         [backtab] #'corfu-previous)
      :init (global-corfu-mode))

    (use-package cape
      :hook (prog-mode . (lambda ()
                           (add-to-list 'completion-at-point-functions #'cape-keywords)))
            (text-mode . (lambda ()
                           (add-to-list 'completion-at-point-functions #'cape-dict)
                           (add-to-list 'completion-at-point-functions #'cape-dabbrev)))
            (org-mode . (lambda ()
                          (add-to-list 'completion-at-point-functions #'cape-elisp-block)))
      :config (add-to-list 'completion-at-point-functions #'cape-file))

    (use-package company-wordfreq
      :init (add-to-list 'completion-at-point-functions (cape-company-to-capf #'company-wordfreq)))
#+END_SRC

*** Other Built-in Modes

#+begin_src emacs-lisp :tangle init.el
  (global-prettify-symbols-mode +1)
#+end_src

** Emacs Lisp Mode

This Emacs configuration is targeted specifically at extensive writing in
=org-mode= and may be extended to a few other writing focused modes (Like LaTeX).
My primary coding editor is neovim and I have no current intention to replace that.

That being said, it's basically impossible to be configuring Emacs and /not/ writing
some amount of elisp, so we'll definitely want a few packages to help with that.

For heavy lisp editing, I will probably want to configure =lispy= and =lispyville=,
but I don't need those yet so I'm choicing to procrastinate.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (use-package macrostep
    :commands marcostep-expand
    :general (mjs-leader-def :states '(normal insert)
               :keymaps 'emacs-lisp-mode-map
               "e" '("Expand Macro" . macrostep-expand)))

  (use-package elisp-def
    :commands elisp-def
    :general (mjs-leader-def :states '(normal insert)
               :keymaps 'emacs-lisp-mode-map
               "d" '("Find Definition" . elisp-def)))

  (use-package elisp-demos
    :config (advice-add 'helpful-update
                        :after #'elisp-demos-advice-helpful-update))

  (use-package highlight-quoted
    :diminish highlight-quoted-mode
    :hook (emacs-lisp-mode . highlight-quoted-mode))
#+END_SRC

** Org Mode

This is the primary reason why I use Emacs in the first place, so the =org-mode=
configuration should be quite extensive.

For some reason, it would seem that =evil= and =org= aren't the greatest of
friends and this can have some interesting impacts on how =src= blocks are
indented while editing them inside the =org= document directly. Behaviors I've
seem include inserting 2 spaces at the beginning of each line when I hit
=<return>= and hitting =<tab>= having no effect.

The below block makes a solid but not perfect attempt to correct some of these
issues. This code was taken almost directly from DOOM Emacs. The last piece of
the puzzle was setting =tab-always-indent= to =nil=, which ironically fixed the
problem of =<tab>= not always indenting the file. I do believe that there is
more work that can be done here, but for the moment it works well enough to
continue to work on this configuration.

TODO: Fix the 2 space indentation which is reset when =<tab>= is pressed.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (defun mjs/org-babel-remove-result-blocks (remove-all)
    (interactive "P")
    (let ((pos (point)))
      (org-babel-map-src-blocks nil
        (if (or remove-all (< pos end-block))
            (org-bable-remove-results)))))

  (use-package org
    :general (mjs-leader-def :states '(normal insert visual)
               :keymaps 'org-mode-map
               "a" '("Agenda" . org-agenda)
               "A" '("GTD Agenda" . (lambda () (interactive) (org-agenda nil "g")))
               "n"     '(nil :which-key "Notes")
               "n a"   '("Agenda" . org-agenda)
               "n c"   '("Capture" . org-capture)
               "n l"   '("Store Link" . org-store-link)
               "n R"   '("Refile DWIM" . mjs/org-refile-dwim)
               "n s"   '("Search Notes" . org-search-view)
               "n t"   '("TODO List" . org-todo-list)
               "n T"   '("Tag View" . org-tags-view))
             (mjs-local-leader-def :states '(normal insert visual)
               :keymaps 'org-mode-map
               "a"      '("Archive" . org-archive-subtree)
               "A"      '("Attach" . org-attach)
               "b"      '(nil :which-key "Tables")
               "b a"    '("Align" . org-table-align)
               "b b"    '("Blank" . org-table-blank-field)
               "b c"    '("Convert to Table" . org-table-create-or-convert-from-region)
               "b d"    '(nil :which-key "Delete")
               "b d c"  '("Delete Column" . org-table-delete-column)
               "b d r"  '("Delere Row" . org-table-kill-row)
               "b e"    '("Edit" . org-table-edit-field)
               "b f"    '("Edit Formulas" . org-table-edit-formulas)
               "b h"    '("Help" . org-table-field-info)
               "b i"    '(nil :which-key "Insert")
               "b i c"  '("Insert Column" . org-table-insert-column)
               "b i r"  '("Insert Row" . org-table-insert-row)
               "b i h"  '("Insert Hline" . org-table-insert-hline)
               "b i H"  '("Insert Hline & Move" . org-table-hline-and-move)
               "b s"    '("Sort Rows" . org-table-sort-lines)
               "b r"    '("Recalculate Formulas" . org-table-recalculate)
               "b R"    '("Recalculate All Tables" . org-table-recalculate-buffer-tables)
               "b t"    '("Toggle Table.el" . org-table-create-with-table.el)
               "b -"    '("Insert Hline" . org-table-insert-hline)
               "B"      '(nil :which-key "Babel")
               "B t"    '("Tangle" . org-babel-tangle)
               "B e"    '("Execute Block" . org-babel-execute-src-block)
               "B E"    '("Execute Buffer" . org-babel-execute-buffer)
               "B h"    '("Hide Result" . org-babel-hide-result-toggle)
               "B H"    '("Hide All Results" . org-babel-result-hide-all)
               "B k"    '("Remove Result" . org-babel-remove-result)
               "B K"    '("Remove All Results" . mjs/org-babel-remove-result-blocks)
               "B n"    '("Next Src Block" . org-babel-next-src-block)
               "B p"    '("Pervious Src Block" . org-babel-previous-src-block)
               "c"      '(nil :which-key "Clock")
               "c e"    '("Set Effort" . org-set-effort)
               "c E"    '("Increase Effort" . org-inc-effort)
               "c i"    '("Clock-in" . org-clock-in)
               "c o"    '("Clock-out" . org-clock-out)
               "c g"    '("Goto Current Clock" . org-clock-goto)
               "c c"    '("Cancel Clock" . org-clock-cancel)
               "c r"    '("Report" . org-clock-report)
               "C"      '("Capture" . org-capture)
               "d"      '(nil :which-key "Date")
               "d d"    '("Deadline" . org-deadline)
               "d s"    '("Schedule" . org-schedule)
               "d t"    '("Time Stamp" . org-time-stamp)
               "d T"    '("Inactive Time Stamp" . org-time-stamp-inactive)
               "f"      '(nil :whick-key "File Links")
               "f m"    '("Move File" . mjs/move-and-update-file-links)
               "f d"    '("Move Directory" . mjs/move-dir-update-link-links)
               "f r"    '("Regenerate Links" . mjs/regenerate-file-links)
               "f R"    '("Regenerate Links Globally" . mjs/regenerate-file-links-globally)
               "h"      '("Toggle Heading" . org-toggle-heading)
               "i"      '(nil :which-key "ID")
               "i c"    '("Copy ID" . org-id-copy)
               "i i"    '("Create ID" . org-id-get-create)
               "i g"    '("Goto ID" . org-id-goto)
               "i u"    '("Update IDs" . org-id-update-id-locations)
               "I"      '("Create ID" . org-id-get-create)
               "l"      '(nil :which-key "Links")
               "l i"    '("Store ID Link" . org-id-store-link)
               "l l"    '("Insert Link" . org-insert-link)
               "l L"    '("Insert All Links" . org-insert-all-links)
               "l t"    '("Toggle Links" . org-toggle-link-display)
               "l s"    '("Store Link" . org-store-link)
               "l S"    '("Insert Stored Link" . org-insert-last-stored-link)
               "m"      '(nil :which-key "Roam")
               "m b"    '("Toggle Roam Buffer" . org-roam-buffer-toggle)
               "m f"    '("Find Node" . org-roam-node-find)
               "m F"    '("Find Ref" . org-roam-ref-find)
               "m g"    '("Graph" . org-roam-graph)
               "m i"    '("Insert Link" . org-roam-node-insert)
               "m c"    '("Roam Capture" . org-roam-capture)
               "m s"    '("Roam Sync" . org-roam-db-sync)
               "m S"    '("Stripe Roam Links" . mjs/strip-org-roam-links)
               "m d"    '("Daily" . org-roam-dailies-capture-today)
               "m r"    '("Random Node" . org-roam-node-random)
               "r"      '("Refile" . org-refile)
               "R"      '("Refile DWIM" . mjs/org-refile-dwim)
               "s"      '("Search Headings" . consult-org-heading)
               "S"      '(nil :which-key "Subtree")
               "S a"    '("Toggle Archive Tag" . org-toggle-archive-tag)
               "S A"    '("Archive" . org-archive-subtree)
               "S b"    '("Move to Buffer" . org-tree-to-indirect-buffer)
               "S c"    '("Clone" . org-clone-subtree-with-time-shift)
               "S d"    '("Delete" . org-cut-subtree)
               "S h"    '("Promote" . org-promote-subtree)
               "S j"    '("Move Down" . org-move-subtree-down)
               "S k"    '("Move Up" . org-move-subtree-up)
               "S l"    '("Demote" . org-demote-subtree)
               "S n"    '("Narrow to Subtree" . org-narrow-to-subtree)
               "S N"    '("Widen" . widen)
               "S r"    '("Refile" . org-refile)
               "S s"    '("Sparse Subtree" . org-sparse-tree)
               "S S"    '("Sort" . org-sort)
               "t"      '("Set TODO State" . org-todo)
               "T"      '("Set Tags" . org-set-tags-command)))

  (defun mjs/org-fix-newline-and-indent (&optional indent _arg _interactive)
    "Mimic `newline-and-indent' in src blocks w/ lang-appropriate indentation."
    (when (and org-src-tab-acts-natively (org-in-src-block-p t))
      (save-window-excursion
        (org-babel-do-in-edit-buffer
         (call-interactively #'indent-for-tab-command)))))

  (advice-add #'org-return :after #'mjs/org-fix-newline-and-indent)

  (defun mjs/org-return (&optional indent arg interactive)
    "Automatically indent when calling `org-return'."
    (interactive)
    (org-return electric-indent-mode))
  (general-define-key :states 'insert :keymaps 'org-mode-map "RET" #'mjs/org-return)

  (setq tab-always-indent nil)
  ;; (setq org-src-preserve-indentation t)
#+END_SRC
*** Org keybinds

**** Return

This is the do-what-I-mean function from DOOM Emacs. I like it a lot, so I've
lifted it directly from DOOM.

#+begin_src emacs-lisp :tangle init.el
  (defun mjs/org-dwim-at-point (&optional arg)
    "Do-what-I-mean at point.

  If on a:
  - checkbox list item or todo heading: toggle it.
  - citation: follow it
  - headline: cycle ARCHIVE subtrees, toggle latex fragments and inline images in
    subtree; update statistics cookies/checkboxes and ToCs.
  - clock: update its time.
  - footnote reference: jump to the footnote's definition
  - footnote definition: jump to the first reference of this footnote
  - timestamp: open an agenda view for the time-stamp date/range at point.
  - table-row or a TBLFM: recalculate the table's formulas
  - table-cell: clear it and go into insert mode. If this is a formula cell,
    recaluclate it instead.
  - babel-call: execute the source block
  - statistics-cookie: update it.
  - src block: execute it
  - latex fragment: toggle it.
  - link: follow it
  - otherwise, refresh all inline images in current tree."
    (interactive "P")
    (if (button-at (point))
        (call-interactively #'push-button)
      (let* ((context (org-element-context))
             (type (org-element-type context)))
        ;; skip over unimportant contexts
        (while (and context (memq type '(verbatim code bold italic underline strike-through subscript superscript)))
          (setq context (org-element-property :parent context)
                type (org-element-type context)))
        (pcase type
          ((or `citation `citation-reference)
           (org-cite-follow context arg))

          (`headline
           (cond ((memq (bound-and-true-p org-goto-map)
                        (current-active-maps))
                  (org-goto-ret))
                 ((and (fboundp 'toc-org-insert-toc)
                       (member "TOC" (org-get-tags)))
                  (toc-org-insert-toc)
                  (message "Updating table of contents"))
                 ((string= "ARCHIVE" (car-safe (org-get-tags)))
                  (org-force-cycle-archived))
                 ((or (org-element-property :todo-type context)
                      (org-element-property :scheduled context))
                  (org-todo
                   (if (eq (org-element-property :todo-type context) 'done)
                       (or (car (+org-get-todo-keywords-for (org-element-property :todo-keyword context)))
                           'todo)
                     'done))))
           ;; Update any metadata or inline previews in this subtree
           (org-update-checkbox-count)
           (org-update-parent-todo-statistics)
           (when (and (fboundp 'toc-org-insert-toc)
                      (member "TOC" (org-get-tags)))
             (toc-org-insert-toc)
             (message "Updating table of contents"))
           (let* ((beg (if (org-before-first-heading-p)
                           (line-beginning-position)
                         (save-excursion (org-back-to-heading) (point))))
                  (end (if (org-before-first-heading-p)
                           (line-end-position)
                         (save-excursion (org-end-of-subtree) (point))))
                  (overlays (ignore-errors (overlays-in beg end)))
                  (latex-overlays
                   (cl-find-if (lambda (o) (eq (overlay-get o 'org-overlay-type) 'org-latex-overlay))
                               overlays))
                  (image-overlays
                   (cl-find-if (lambda (o) (overlay-get o 'org-image-overlay))
                               overlays)))
             (+org--toggle-inline-images-in-subtree beg end)
             (if (or image-overlays latex-overlays)
                 (org-clear-latex-preview beg end)
               (org--latex-preview-region beg end))))

          (`clock (org-clock-update-time-maybe))

          (`footnote-reference
           (org-footnote-goto-definition (org-element-property :label context)))

          (`footnote-definition
           (org-footnote-goto-previous-reference (org-element-property :label context)))

          ((or `planning `timestamp)
           (org-follow-timestamp-link))

          ((or `table `table-row)
           (if (org-at-TBLFM-p)
               (org-table-calc-current-TBLFM)
             (ignore-errors
               (save-excursion
                 (goto-char (org-element-property :contents-begin context))
                 (org-call-with-arg 'org-table-recalculate (or arg t))))))

          (`table-cell
           (org-table-blank-field)
           (org-table-recalculate arg)
           (when (and (string-empty-p (string-trim (org-table-get-field)))
                      (bound-and-true-p evil-local-mode))
             (evil-change-state 'insert)))

          (`babel-call
           (org-babel-lob-execute-maybe))

          (`statistics-cookie
           (save-excursion (org-update-statistics-cookies arg)))

          ((or `src-block `inline-src-block)
           (org-babel-execute-src-block arg))

          ((or `latex-fragment `latex-environment)
           (org-latex-preview arg))

          (`link
           (let* ((lineage (org-element-lineage context '(link) t))
                  (path (org-element-property :path lineage)))
             (if (or (equal (org-element-property :type lineage) "img")
                     (and path (image-type-from-file-name path)))
                 (+org--toggle-inline-images-in-subtree
                  (org-element-property :begin lineage)
                  (org-element-property :end lineage))
               (org-open-at-point arg))))

          (`paragraph
           (+org--toggle-inline-images-in-subtree))

          ((guard (org-element-property :checkbox (org-element-lineage context '(item) t)))
           (let ((match (and (org-at-item-checkbox-p) (match-string 1))))
             (org-toggle-checkbox (if (equal match "[ ]") '(16)))))

          (_
           (if (or (org-in-regexp org-ts-regexp-both nil t)
                   (org-in-regexp org-tsr-regexp-both nil  t)
                   (org-in-regexp org-link-any-re nil t))
               (call-interactively #'org-open-at-point)
             (+org--toggle-inline-images-in-subtree
              (org-element-property :begin context)
              (org-element-property :end context))))))))
  (general-define-key :states 'normal :keymaps 'org-mode-map "RET"
                      #'mjs/org-dwim-at-point)
#+end_src

**** Control Return

Also taken from DOOM Emacs.

#+begin_src emacs-lisp :tangle init.el
    (defun mjs--org-insert-item (direction)
    (let ((context (org-element-lineage
                    (org-element-context)
                    '(table table-row headline inlinetask item plain-list)
                    t)))
      (pcase (org-element-type context)
        ;; Add a new list item (carrying over checkboxes if necessary)
        ((or `item `plain-list)
         (let ((orig-point (point)))
           ;; Position determines where org-insert-todo-heading and `org-insert-item'
           ;; insert the new list item.
           (if (eq direction 'above)
               (org-beginning-of-item)
             (end-of-line))
           (let* ((ctx-item? (eq 'item (org-element-type context)))
                  (ctx-cb (org-element-property :contents-begin context))
                  ;; Hack to handle edge case where the point is at the
                  ;; beginning of the first item
                  (beginning-of-list? (and (not ctx-item?)
                                           (= ctx-cb orig-point)))
                  (item-context (if beginning-of-list?
                                    (org-element-context)
                                  context))
                  ;; Horrible hack to handle edge case where the
                  ;; line of the bullet is empty
                  (ictx-cb (org-element-property :contents-begin item-context))
                  (empty? (and (eq direction 'below)
                               ;; in case contents-begin is nil, or contents-begin
                               ;; equals the position end of the line, the item is
                               ;; empty
                               (or (not ictx-cb)
                                   (= ictx-cb
                                      (1+ (point))))))
                  (pre-insert-point (point)))
             ;; Insert dummy content, so that `org-insert-item'
             ;; inserts content below this item
             (when empty?
               (insert " "))
             (org-insert-item (org-element-property :checkbox context))
             ;; Remove dummy content
             (when empty?
               (delete-region pre-insert-point (1+ pre-insert-point))))))
        ;; Add a new table row
        ((or `table `table-row)
         (pcase direction
           ('below (save-excursion (org-table-insert-row t))
                   (org-table-next-row))
           ('above (save-excursion (org-shiftmetadown))
                   (+org/table-previous-row))))

        ;; Otherwise, add a new heading, carrying over any todo state, if
        ;; necessary.
        (_
         (let ((level (or (org-current-level) 1)))
           ;; I intentionally avoid `org-insert-heading' and the like because they
           ;; impose unpredictable whitespace rules depending on the cursor
           ;; position. It's simpler to express this command's responsibility at a
           ;; lower level than work around all the quirks in org's API.
           (pcase direction
             (`below
              (let (org-insert-heading-respect-content)
                (goto-char (line-end-position))
                (org-end-of-subtree)
                (insert "\n" (make-string level ?*) " ")))
             (`above
              (org-back-to-heading)
              (insert (make-string level ?*) " ")
              (save-excursion (insert "\n"))))
           (run-hooks 'org-insert-heading-hook)
           (when-let* ((todo-keyword (org-element-property :todo-keyword context))
                       (todo-type    (org-element-property :todo-type context)))
             (org-todo
              (cond ((eq todo-type 'done)
                     ;; Doesn't make sense to create more "DONE" headings
                     (car (+org-get-todo-keywords-for todo-keyword)))
                    (todo-keyword)
                    ('todo)))))))

      (when (org-invisible-p)
        (org-show-hidden-entry))
      (when (and (bound-and-true-p evil-local-mode)
                 (not (evil-emacs-state-p)))
        (evil-insert 1))))
    ;; I use these instead of `org-insert-item' or `org-insert-heading' because they
    ;; impose bizarre whitespace rules depending on cursor location and many
    ;; settings. These commands have a much simpler responsibility.
    (defun mjs/org-insert-item-below (count)
        "Inserts a new heading, table cell or item below the current one."
        (interactive "p")
        (dotimes (_ count) (mjs--org-insert-item 'below)))

    (defun mjs/org-insert-item-above (count)
      "Inserts a new heading, table cell or item above the current one."
      (interactive "p")
      (dotimes (_ count) (mjs--org-insert-item 'above)))

    (general-define-key :states '(normal insert)
                        :keymaps '(org-mode-map evil-org-mode-map)
                        "C-<return>"   #'mjs/org-insert-item-below
                        "C-S-<return>" #'mjs/org-insert-item-above)
#+end_src

*** Built-in Modes

#+BEGIN_SRC emacs-lisp :tangle init.el
  (customize-set-variable 'org-directory "~/Documents/")

  (add-hook 'org-mode-hook 'auto-fill-mode)
  (diminish 'auto-fill-function)
  (customize-set-variable 'org-startup-with-inline-images t)
  (customize-set-variable 'org-image-actual-width '(600))
  (customize-set-variable 'org-startup-align-all-tables t)
  (customize-set-variable 'org-startup-folded 'showall)
#+END_SRC

**** Babel

#+BEGIN_SRC emacs-lisp :tangle init.el
  (use-package ob-rust
    :after org
    :demand t)

  (org-babel-do-load-languages
      'org-babel-load-languages
      '((C . t)
        (emacs-lisp . t)
        (latex . t)
        (python . t)
        (R . t)
        (java . t)
        (rust . t)))

  (require 'org-tempo)

  ;; There should be a better way to do this, but I haven't found it yet
  (add-to-list 'org-structure-template-alist '("sC" . "src C"))
  (add-to-list 'org-structure-template-alist '("cp" . "src cpp"))
  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("t" . "src latex"))
  (add-to-list 'org-structure-template-alist '("p" . "src python"))
  (add-to-list 'org-structure-template-alist '("r" . "src rust"))
  (add-to-list 'org-structure-template-alist '("R" . "src R"))
  (add-to-list 'org-structure-template-alist '("j" . "src java"))
#+END_SRC

***** Eros Mode

When working with Emacs Lisp (which is rather frequently), we can use
=eval-last-sexp= to slowly evaluate lisp. Eros displays the result of the
evaluation and displays it as an overlay, rather than printing it to the
mini-buffer.

#+begin_src emacs-lisp :tangle init.el
  (use-package eros
    :after org
    :hook (org-mode . eros-mode))
#+end_src

**** Org Tags

Tags are something I intend to use more and more for searching through my org
files. Since many of the tags are standardized across many of my notes, I'm
going to define the hierarchy here so that I don't have to re-define all of the
tags in each file. The hierarchy has the below structure.

- Knowledge Base
  - Mathematics
    - Statistics
      - Regression
      - Confidence Intervals
      - Hypothesis Tests
      - Probability
    - Modeling
      - Text Mining
      - Recommender
      - Clustering
      - Association Analysis
      - Classification
      - Information Retrieval
      - Decision Tree
    - Combinatorics
    - Linear Algebra
  - Programming
    - C
    - lisp
  - Processes
  - Computer Operation
    - Network
  - Unix
- Needs Merge
- Great Basin
  - faction
  - roks
    - valt
  - koncord
  - vi
  - caerwent
  - atrxous
  - kudw
  - eichen
  - arendelle
  - lake
  - trobreryn
  - death raising
  - xylte
  - galimatias
  - andorr again
  - niven
  - syndicate
  - atreides
  - Character
    - npc
      - herald
      - deity
      - elemental_beast
    - player
  - Object
  - Location
  - Session
  - Stat
- Etera
- Obscured Realms

#+begin_src emacs-lisp :tangle init.el
  (setq org-tag-persistent-alist
        '((:startgroup)
          ("knowledge_base")
          ("great_basin")
          ("etera")
          ("obscured_realms")
          (:endgroup)
          ("needs_merge")
          (:startgrouptag)
          ("knowledge_base")
          (:grouptags)
          ("computer_operation")
          ("matematics")
          ("processes")
          ("programming")
          (:endgrouptag)
          (:startgrouptag)
          ("mathematics")
          (:grouptags)
          ("combinatorics")
          ("linear_algebra")
          ("modeling")
          ("statistics")
          (:endgrouptag)
          (:startgrouptag)
          ("programming")
          (:grouptags)
          ("C")
          ("lisp")
          (:endgrouptag)
          (:startgrouptag)
          ("computer_operation")
          (:grouptags)
          ("network")
          (:endgrouptag)
          (:startgrouptag)
          ("statistics")
          (:grouptags)
          ("confidence_intervals")
          ("hypthoesis_tests")
          ("probability")
          ("regression")
          (:endgrouptag)
          (:startgrouptag)
          ("modeling")
          (:grouptags)
          ("association_analysis")
          ("classification")
          ("clustering")
          ("decision_tree")
          ("information_retrival")
          ("recommender")
          ("text_mining")
          ("regression")
          (:endgrouptag)
          (:startgrouptag)
          ("great_basin")
          (:grouptags)
          ("character")
          ("event")
          ("faction")
          ("location")
          ("object")
          ("session")
          ("stat")
          ;; Start of individual factions
          ("andorr_again")
          ("arendelle")
          ("atreides")
          ("atrxous")
          ("caerwent")
          ("death_raising")
          ("eichen")
          ("galimatias")
          ("lake")
          ("koncord")
          ("kudw")
          ("niven")
          ("roks")
          ("syndicate")
          ("trobreryn")
          ("vi")
          ("xylte")
          (:endgrouptag)
          (:startgroup)
          ("character")
          (:grouptags)
          ("player")
          ("npc")
          (:endgroup)
          (:startgrouptag)
          ("npc")
          (:grouptags)
          ("deity")
          ("elemental_beast")
          ("herald")
          (:endgrouptag)
          (:startgrouptag)
          ("roks")
          (:grouptags)
          ("valt")
          (:endgrouptag)))
#+end_src

**** Org Agenda

#+begin_src emacs-lisp :tangle init.el
    (setq org-agenda-start-with-log-mode t)
    ;; Log the time a task is completed in a property drawer.
    (setq org-log-done 'time)
    (setq org-log-into-drawer t)
    ;; hide tags from agenda view, I'll probably be using the `#+CATEGORY'
    ;; more often anyways
    (setq org-agenda-hide-tags-regexp ".")

    (customize-set-variable 'org-agenda-files
                            (list (concat org-directory "agenda/")))

    (setq org-todo-keywords
          '((sequence "TODO(t)" "NEXT(n)" "BLOCKED(b)" "|" "DONE(d)" "KILLED(k)")))
    (defun log-todo-next-creation-date (&rest ignore)
      "Log NEXT creation time in the property drawer under the key 'ACTIVATED'"
      (when (and (string= (org-get-todo-state) "NEXT")
               (not (org-entry-get nil "ACTIVATED")))
      (org-entry-put nil "ACTIVATED" (format-time-string "[%Y-%m-%d]"))))
    (add-hook 'org-after-todo-state-change-hook #'log-todo-next-creation-date)

    (setq org-agenda-custom-commands
        '(("g" "Get Things Done"
           ((agenda ""
                    ((org-agenda-skip-function
                      '(org-agenda-skip-entry-if 'deadline))
                     (org-deadline-warning-days 0)
                     (org-agenda-span 1)))
            (todo "NEXT"
                  ((org-agenda-skip-function
                    '(org-agenda-skip-entry-if 'deadline))
                   (org-agenda-prefix-format "  %i %-12:c [%e] ")
                   (org-agenda-overriding-header "\nTasks\n")))
            (agenda nil
                    ((org-agenda-entry-types '(:deadline))
                     (org-agenda-format-date "")
                     (org-deadline-warning-days 7)
                     (org-agenda-skip-function
                      '(org-agenda-skip-entry-if 'notregexp "\\* NEXT"))
                     (org-agenda-overriding-header "\nDeadlines")))
            (tags-todo "inbox"
                       ((org-agenda-prefix-format "  %?-12t% s")
                        (org-agenda-overriding-header "\nInbox\n")))
            (tags "CLOSED>=\"<today>\""
                  ((org-agenda-overriding-header "\nCompleted today\n")))))))
#+end_src

**** Org Contacts

This simple to use but very poorly documented package will help me track
birthdays, addresses, etc. of people I know. It can even add them to my agenda
automatically.

#+begin_src emacs-lisp :tangle init.el
  (use-package org-contacts
    :after org
    :custom (org-contacts-files
             (list (concat org-directory "contacts.org"))))
#+end_src

**** Org Capture

Update the capture headers to use =evil= keybindings. This is the line of text
which tells you how to save the capture, normally =C-c C-f=, =C-c C-k= and =C-c C-r=
(I think). I've changed those to display the =evil= keybidings defined below.

#+begin_src emacs-lisp :tangle init.el
  (mjs-leader-def :states '(normal insert) :keymaps 'org-capture-mode-map
    "C"   '(nil :which-key "Capture")
    "C f" '("Finish Capture" . org-capture-finalize)
    "C k" '("Abort Capture" . org-capture-kill)
    "C r" '("Refile Capture" . org-capture-refile))

  (defun mjs/org-capture-update-header ()
    (setq header-line-format
          (format "%s%s%s"
                  (propertize (abbreviate-file-name
                               (buffer-file-name (buffer-base-buffer)))
                               'face 'font-lock-string-face)
                  " ⟶ "
                  (concat
                   "Capture Buffer. Finish "
                   (propertize "SPC C f" 'face 'help-key-binding)
                   ", refile "
                   (propertize "SPC C r" 'face 'help-key-binding)
                   ", abort "
                   (propertize "SPC C k" 'face 'help-key-binding)
                   " in normal mode."
                   ))))

  (add-hook 'org-capture-mode-hook #'mjs/org-capture-update-header)
#+end_src

***** Templates

Here I will define capture templates for the following things:
- Pathfinder: Great Basin
  - Character
  - Event
  - Session
  - Item
  - Location
- Knowledge Base Entry
- Class lecture
- Inbox Item
- New Contact

#+begin_src emacs-lisp :tangle init.el
  (defun mjs/named-capture (prompt base-dir)
    (let* ((character-name (read-string prompt))
           (file-name (expand-file-name
                       (concat base-dir
                               (downcase
                                (string-replace " " "-"
                                 (replace-regexp-in-string
                                  "[^[:alnum:] ]" ""
                                  character-name)))
                               ".org")
                       org-directory)))
      (setq mjs--capture-title character-name)
      (set-buffer (org-capture-target-buffer file-name))
      (goto-char (point-min))))

  (defun mjs/class-capture ()
    (let* ((class (completing-read "Class: "
                                   '("cs5311" "cs3411" "cs1121")
                                   nil t))
           (file-name (expand-file-name
                       (concat "classes/" class "/"
                               (format-time-string "%Y-%m-%d" (current-time))
                               "-" class ".org")
                       org-directory)))
      (setq mjs--capture-title class)
      (set-buffer (org-capture-target-buffer file-name))
      (goto-char (point-min))))

  (defun mjs/capture-insert-id ()
    (save-excursion
      (goto-char (point-min))
      (org-id-get-create)))

  (add-hook 'org-capture-mode-hook (lambda () (flycheck-mode -1)))
  (setq org-capture-templates
        `(("c" "Class Lecture" plain
           (function (lambda () (mjs/class-capture)))
           ,(concat "#+filetags: :%(format mjs--capture-title):\n"
                    "#+title: %(format mjs--capture-title) (%<%d %B %Y>)\n"
                    "#+author: %(user-full-name)\n\n%?")
           :jump-to-captured t 
           :immediate-finish t)
          ("C" "New Contact" entry
           (file+headline ,(concat org-directory "contacts.org") "Other")
           ,(concat
             "** %(org-contacts-template-name)\n"
             ":PROPERTIES:\n"
             ":ADDRESS: %^{Address?}\n"
             ":BIRTHDAY: %^{yyyy-mm-dd}\n"
             ":EMAIL: %(org-contacts-template-email)\n"
             ":NOTE: %?\n"
             ":END:")
           :empty-lines 1)
          ("g" "Great Basin")
          ("gc" "Great Basin Character" plain
            (function (lambda ()
                        (mjs/named-capture
                         "Character Name: "
                         "ttrpg/great-basin/characters/")))
            (file "ttrpg/great-basin/characters/template.org")
            :jump-to-captured t
            ;; The docs say this has to be a 'nullary function' and
            ;; even thought it /is/ a nullary function if it's not
            ;; wrapped in the lmabda I get an error.
            :hook (lambda () (mjs/capture-insert-id)))
          ("ge" "Great Basin Event" plain
           (function (lambda ()
                       (mjs/named-capture
                        "Event Name: "
                        "ttrpg/great-basin/events/")))
           (file "ttrpg/great-basin/events/template.org")
           :jump-to-captured t
           :hook (lambda () (mjs/capture-insert-id)))
          ("gl" "Great Basin Location" plain
           (function (lambda ()
                       (mjs/named-capture
                        "Location Name: "
                        "ttrpg/great-basin/locations/")))
           (file "ttrpg/great-basin/locations/template.org")
           :jump-to-captured t
           :hook (lambda () (mjs/capture-insert-id)))
          ("go" "Great Basin Object" plain
           (function (lambda ()
                       (mjs/named-capture
                        "Object Name: "
                        "ttrpg/great-basin/objects/")))
           (file "ttrpg/great-basin/objects/template.org")
           :jump-to-captured t
           :hook (lambda () (mjs/capture-insert-id)))
          ;; Replace this with something not dependent on Eamcs restarts
          ("gr" "Great Basin Session Record" plain
            (file ,(format "ttrpg/great-basin/sessions/great-basin-%s.org"
                    (org-read-date nil nil "Sun")))
            (file "ttrpg/great-basin/sessions/template.org")
            :jump-to-captured t
            :immediate-finish t)
          ("gs" "Great Basin Stat Block" plain
           (function (lambda ()
                       (mjs/named-capture
                        "Stat Block Name: "
                        "ttrpg/great-basin/stat-blocks/")))
           (file "ttrpg/great-basin/stat-blocks/template.org")
           :jump-to-captured t
           :hook (lambda () (mjs/capture-insert-id)))
          ("i" "Inbox" entry
           (file "agenda/inbox.org")
           ,(concat "* TODO %?\n"
                    "/Entered on/ %U")
           :empty-lines 1
           :prepend t)
          ("k" "Knowledge Base" plain
           (function (lambda ()
                       (mjs/named-capture
                        "Node Name: "
                        "knowledge-base/")))
            ,(concat "#+filetags: :knowledge_base:\n"
                     "#+author: %(user-full-name)\n"
                     "#+title: %(format mjs--capture-title)\n\n%?")
           :hook (lambda () (mjs/capture-insert-id)))
          ("m" "Meeting" entry
           (file+headline "agenda/agenda.org" "Future")
           ,(concat "* %? :meeting:\n"
                    "SCHEDULED: %^{Meeting Time}T"))
          ("n" "Meeting Notes" entry
           (file "agenda/notes.org")
           ,(concat "* Notes (%a)\n"
                    "/Entered on/ %U\n\n%?"))))
#+end_src

**** Org Refile

#+begin_src emacs-lisp :tangle init.el
  ;; Save the buffers after refile
  (advice-add #'org-refile :after #'org-save-all-org-buffers)

  (setq org-refile-targets
        '(("projects.org" :regexp . "\\(?:\\(?:Note\\|Task\\)s\\)")))
  (setq org-refile-use-outline-path 'file)
  (setq org-outline-path-complete-in-steps nil)
#+end_src

**** LaTeX Fragments

This package is similar to =org-appear= but works with LaTeX previews for math
equations. It is currently configured to always preview all LaTeX fragments in a
document upon opening it, and then I have a cheeky method to simulate the manual
mode from =org-appear= for evil insert state hooks. Finally, the exit hook
configuration will preview the current LaTeX fragment if we ~<escape>~ while
inside it.

Below is a test fragment.

$$ \binom{n}{k} = \frac{n!}{k! \times (n-k)!} $$

#+begin_src emacs-lisp :tangle init.el
  (customize-set-variable 'org-startup-with-latex-preview nil)
  (setq org-format-latex-options
        (plist-put org-format-latex-options :scale 1.5))
  (add-to-list 'org-latex-packages-alist '("" "sfmath" t))
  (add-to-list 'org-latex-packages-alist '("margin=1in" "geometry" t))
  (add-to-list 'org-latex-packages-alist '("" "parskip" t))

  (use-package org-fragtog
   :hook (org-mode . (lambda ()
                       (add-hook 'evil-insert-state-entry-hook
                                 (lambda ()
                                   (when (eq major-mode 'org-mode)
                                     (org-fragtog-mode +1))))
                       (add-hook 'evil-insert-state-exit-hook
                                 (lambda ()
                                   (when (eq major-mode 'org-mode)
                                     (progn
                                       (org-fragtog-mode -1)
                                       (if (org-inside-LaTeX-fragment-p)
                                           (org-latex-preview)))))))))
#+end_src

*** Org Appear

This package performs automatic hiding of emphasis markers like Obsidian's live
preview feature.

#+begin_src emacs-lisp :tangle init.el
  (use-package org-appear
    :after org
    :custom (org-hide-emphasis-markers t)
            (org-appear-autolinks t)
            (org-appear-trigger 'manual)
    :hook (org-mode . (lambda ()
                         (org-appear-mode t)
                         (add-hook 'evil-insert-state-entry-hook
                                   #'org-appear-manual-start nil t)
                         (add-hook 'evil-insert-state-exit-hook
                                   #'org-appear-manual-stop nil t))))
#+end_src

*** Olivetti Mode

This is a simple mode which centers the text on the screen. I have noticed a few
times that when a new window is opened, the centered text doesn't adjust and
becomes truncated, but this seems to be an intermittent issue and I will
investigate when and if it becomes a larger problem.

#+begin_src emacs-lisp :tangle init.el
    (use-package olivetti-mode
      :straight (olivetti :local-repo "olivetti")
      :custom (olivetti-body-width 100)
              (olivetti-lighter " 󰘞")
      :hook org-mode
      :init (diminish 'visual-line-mode)
      :general (mjs-local-leader-def :states '(normal insert)
                 :keymaps 'org-mode-map
                 "o" '("Toggle Olivetti" . olivetti-mode)))
#+end_src

*** Flycheck

Flycheck is syntax checking package. For =org= mode, I'm going to use it to check
my grammar.

#+begin_src emacs-lisp :tangle init.el
  (use-package flycheck
    :diminish " 󰨮"
    :custom (flycheck-global-modes '(not org-capture-mode)))
    ;; :init (global-flycheck-mode))
#+end_src

**** Flycheck Vale

Vale is an open source grammar check which seems easier to use and configure
than =language-tool=, so let's try it out.

#+begin_src emacs-lisp :tangle init.el
  (use-package flycheck-vale
    :config (flycheck-vale-setup))
#+end_src

*** Spell Checking with Jinx

Jinx is a new-ish Emacs package which only spell-checks the portion of the
buffer which is currently visual.

#+begin_src emacs-lisp :tangle init.el
  (use-package jinx
    :diminish " 󰓆"
    :hook (emacs-startup . global-jinx-mode)
    :general (:states '(normal visual) :keymaps 'jinx-mode-map
                      "z =" #'jinx-correct
                      "Z =" #'jinx-languages)
              (:keymaps 'evil-motion-state-map
                        "[ s" #'jinx-previous
                        "] s" #'jinx-next))
#+end_src

*** Org Appearance

**** Org Superstar

Replace those boring '*' we use for org headlines with exciting Unicode
characters! Also, enable =org-indent-mode= and hide the leading stars.

#+begin_src emacs-lisp :tangle init.el
  (add-hook 'org-mode-hook 'org-indent-mode)
  (add-hook 'org-indent-mode-hook (lambda () (diminish 'org-indent-mode)))
  
  (use-package org-superstar-mode
    :straight (org-superstar :local-repo "org-superstar")
    :after org
    :custom (org-superstar-leading-bullet nil)
            (org-hide-leading-stars t)
    :hook org-mode)
#+end_src

**** Org SVG Tags 

Replace tags with neatly rendered SVG images!

#+begin_src emacs-lisp :tangle init.el
  (use-package svg-tag-mode
    :hook org-mode
    :custom (svg-tag-tags
             '(("^\\*+ \\(TODO\\)" .
                ((lambda (tag)
                   (svg-lib-tag tag nil
                     :margin 0
                     :font-family "JetBrainsMono"
                     :font-weight 500
                     :background (alist-get 'peach catppuccin-frappe-colors)
                     :foreground (alist-get 'base catppuccin-frappe-colors)
                     )))))))
#+end_src

*** Org Table of Contents

#+begin_src emacs-lisp :tangle init.el
  (use-package toc-org
    :hook (org-mode . toc-org-mode))
#+end_src

*** PDF Support

Most of this configuration is taken from DOOM Emacs.

#+begin_src emacs-lisp :tangle init.el
  (use-package pdf-tools
    :mode ("\\.pdf\\'" . pdf-view-mode)
    :magic ("%PDF" . pdf-view-mode)
    :custom (pdf-view-display-size 'fit-page)
            (pdf-view-use-scaling t)
            (pdf-view-use-imagemagick nil)
    :config
      ;; Silence large file prompts for PDFs
      (defun mjs/suppress-large-file-prompts (fn size op-type filename
                                                 &optional offer-raw)
        (unless (string-match-p "\\.pdf\\'" filename)
          (funcall fn size op-type filename offer-raw)))
      (advice-add #'abort-if-file-too-large :around
                  #'mjs/suppress-large-file-prompts)
      ;; Add message about needing to install the pdf server.
      (defun mjs/install-epdfinfo-message (fn &rest args)
        (if (and (require 'pdf-info nil t)
                 (or (pdf-info-running-p)
                     (ignore-errors (pdf-info-check-epdfinfo) t)))
            (apply fn args)
          (fundamental-mode)
          (message "Viewing PDFs in Emacs requires epdfinfo. Use `M-x pdf-tools-install' to build it")))
      (advice-add #'pdf-view-mode :around #'mjs/install-epdfinfo-message)
      (pdf-tools-install-noverify))

  (use-package saveplace-pdf-view
    :after pdf-view)
#+end_src

**** Org PDF Integration

Provides a custom link type for =org= files. This code block is taken from the
=org-pdftools= README.

#+begin_src emacs-lisp :tangle init.el
    (use-package org-noter
      :config
      ;; Your org-noter config ........
      (require 'org-noter-pdf "~/.config/emacs-configs/mjs/straight/repos/org-pdftools/org-noter-pdftools.el"))

    (use-package org-pdftools
      :hook (org-mode . org-pdftools-setup-link))

    (use-package org-noter-pdftools
      :load-path "straight/repos/org-pdftools/"
      :after org-noter
      :config
      ;; Add a function to ensure precise note is inserted
      (defun org-noter-pdftools-insert-precise-note (&optional toggle-no-questions)
        (interactive "P")
        (org-noter--with-valid-session
         (let ((org-noter-insert-note-no-questions (if toggle-no-questions
                                                       (not org-noter-insert-note-no-questions)
                                                     org-noter-insert-note-no-questions))
               (org-pdftools-use-isearch-link t)
               (org-pdftools-use-freepointer-annot t))
           (org-noter-insert-note (org-noter--get-precise-info)))))

      ;; fix https://github.com/weirdNox/org-noter/pull/93/commits/f8349ae7575e599f375de1be6be2d0d5de4e6cbf
      (defun org-noter-set-start-location (&optional arg)
        "When opening a session with this document, go to the current location.
    With a prefix ARG, remove start location."
        (interactive "P")
        (org-noter--with-valid-session
         (let ((inhibit-read-only t)
               (ast (org-noter--parse-root))
               (location (org-noter--doc-approx-location (when (called-interactively-p 'any) 'interactive))))
           (with-current-buffer (org-noter--session-notes-buffer session)
             (org-with-wide-buffer
              (goto-char (org-element-property :begin ast))
              (if arg
                  (org-entry-delete nil org-noter-property-note-location)
                (org-entry-put nil org-noter-property-note-location
                               (org-noter--pretty-print-location location))))))))
      (with-eval-after-load 'pdf-annot
        (add-hook 'pdf-annot-activate-handler-functions #'org-noter-pdftools-jump-to-note)))
#+end_src

*** Knowledge Base

Most of my knowledge base functionality is done with =org-roam=, but some parts of
my Pathfinder game require =vulpea=, an additional library which extends
=org-roam=.

#+begin_src emacs-lisp :tangle init.el
  (defun mjs/strip-org-roam-links ()
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "\\[\\[id:[^]]*\\]\\[\\([^]]*\\)\\]\\]" nil t)
        (replace-match "\\1" nil nil))))

  (defun mjs/org-refile-dwim (target)
    (interactive "FDestination File: \n")
    (unless (org-at-heading-p)
      (error "Point not at org heading! Aborting"))
    (if (file-exists-p target)
        ;; File does exist, use regular `org-refile'
        (org-refile nil nil target nil)
      (let ((org-tags (map 'list #'substring-no-properties (org-get-tags)))
            (org-heading (substring-no-properties (org-get-heading)))
            (new-node-id nil)
            (old-buf (current-buffer))
            (new-buf (get-buffer-create (file-name-nondirectory target))))
        (org-copy-subtree nil 'cut)
        (switch-to-buffer new-buf)
        (when org-tags ; Insert tags when then exist
          (insert "#+filetags: ")
          (dolist (tag org-tags)
            (insert (concat ":" tag)))
          (insert ":\n"))
        (insert (concat "#+title: " org-heading "\n\n"))
        (write-file target) ; org-roam can only create ids for buffers visiting a file
        (org-id-get-create)
        (setq new-node-id (org-roam-id-at-point))
        (org-paste-subtree)
        (kill-whole-line 2) ; Assumed format is heading followed by blank line
        (org-next-visible-heading 1)
        (when (org-at-heading-p) ; If there is another heading, promote it to first level
          (while (not (eql 1 (nth 0 (org-heading-components))))
            (org-promote-subtree)))
        (goto-char (point-min))
        (write-file target)
        (with-current-buffer old-buf
          (insert (concat "[[id:" new-node-id "][" org-heading "]]\n\n"))))))

  (use-package org-roam
    :custom (org-roam-directory (file-truename org-directory))
    :general (mjs-leader-def :states '(normal insert)
               "n r"   '(nil :which-key "Roam")
               "n r b" '("Toggle Roam Buffer" . org-roam-buffer-toggle)
               "n r f" '("Find Node" . org-roam-node-find)
               "n r F" '("Find Ref" . org-roam-ref-find)
               "n r g" '("Graph" . org-roam-graph)
               "n r i" '("Insert Link" . org-roam-node-insert)
               "n r c" '("Roam Capture" . org-roam-capture)
               "n r s" '("Roam Sync" . org-roam-db-sync)
               "n r S" '("Stripe Roam Links" . mjs/strip-org-roam-links)
               "n r d" '("Daily" . org-roam-dailies-capture-today)
               "n r r" '("Random Node" . org-roam-node-random)
               "i U"   '("Update Roam IDs" . org-roam-update-org-id-locations))
             (:states 'insert :keymaps 'org-roam-mode-map
                      "C-f" #'org-roam-node-insert
                      "C-S-f" #'org-insert-link)
    :hook (org-mode . org-roam-db-autosync-mode))

  (use-package vulpea
    :hook (org-roam-db-autosync-mode . vulpea-db-autosync-enable))
#+end_src

**** File Movement and Maintenance

#+begin_src emacs-lisp :tangle init.el
  (defun mjs/search-org-files (query)
    "Return a list of files in the org directory containing QUERY"
    (split-string
     (shell-command-to-string (format "rg \"%s\" %s" query org-directory))
     ":.*\n" t))

  (defun mjs/move-and-update-file-links (source-file dest-dir &optional search-dir)
    "Move SOURCE-FILE to DEST-DIR, updating all org file links in SEARCH-DIR"
      (interactive "fSource File: \nDDestination Directory: \n")
      (let* ((search-dir (if (stringp search-dir) search-dir org-directory))
             (source-file-name (file-name-nondirectory source-file))
             (dest-file (file-name-concat dest-dir source-file-name))
             (file-regexp
              (format
               "\\[\\[\\(file\\|pdf\\):\\([^]:]*%s\\)\\(::[0-9]+\\)?\\]\\[\\([^]]*\\)\\]\\]"
                               source-file-name)))

        (rename-file source-file dest-file t)
        ; Iterate over all files in the search directory referencing the source file
        (dolist (file (mjs/search-org-files source-file-name))
          (with-current-buffer (find-file-noselect file) ; Open that file as a buffer
          ;; Here is where the find and replace can happen
          (let ((relative-dest-file (file-relative-name dest-file
                                                        (file-name-directory file))))
            (message (concat "Searching with: " file-regexp))
            (goto-char (point-min))
            (while (re-search-forward file-regexp nil t)
              (replace-match relative-dest-file nil nil nil 2)
              )
          (save-buffer)
          ))
        )))

  (defun mjs/move-dir-update-file-links (source-dir dest-dir &optional search-dir)
    "Move SOURCE-DIR into DEST-DIR, updating all file links in SEARCH-DIR referencing files in SOURCE-DIR"
    (interactive "DSource Directory: \nDDestination Directory: \n")
    (let ((search-dir (if (stringp search-dir) search-dir org-directory))
          (dest-file-base (file-name-concat dest-dir
                                            (file-name-nondirectory
                                             (directory-file-name source-dir)))))
      (dolist (file (directory-files-recursively source-dir ".*"))
        (let ((dest-file-dir (expand-file-name
                              (file-relative-name (file-name-directory file) source-dir)
                              dest-file-base)))
          (unless (file-directory-p dest-file-dir)
            (make-directory dest-file-dir))
          (mjs/move-and-update-file-links file dest-file-dir search-dir)
        ))
      (delete-directory source-dir)
    ))

  (defun mjs/regenerate-file-links (src &optional search-dir kill)
    "Regenerate file links in SRC org file by searching SEARCH-DIR and updating file paths"
    (interactive (list (current-buffer)))
    (let* ((search-dir (if (stringp search-dir) search-dir org-directory))
           (src-buf (cond
                 ((bufferp src) src)
                 ((stringp src) (find-file-noselect src)) ; Assume this is a filename
                 (t (current-buffer))))
           (src-file (buffer-file-name src-buf))
           (file-link-regexp
            "\\[\\[\\(file\\|pdf\\):\\([^]:]*\\)\\(::[0-9]+\\)?\\]\\(\\[[^]]*\\]\\)\\]"))
      (with-current-buffer src-buf
        (save-excursion (goto-char (point-min)) ; Move the point to start of buffer
                        (while (re-search-forward file-link-regexp nil t)
                          (let ((rel-dest-file (string-trim (file-relative-name
                                                             (shell-command-to-string
                                                              (format "find %s -name \"%s\""
                                                                      search-dir
                                                                      (file-name-nondirectory
                                                                       (match-string 2))))
                                                             (file-name-directory src-file)))))
                            (replace-match rel-dest-file nil nil nil 2) ; Replace only the file path
                            ))
                        (save-buffer)
                        ))
      (when kill (kill-buffer src-buf))
      ))

  (defun mjs/regenerate-file-links-globally (&optional dir)
    (interactive "DDirectory: \n")
    (let ((dir (if (stringp dir) dir org-directory)))
      (dolist (file (directory-files-recursively dir ".*\\.org"))
        (mjs/regenerate-file-links file nil 'kill)
      )
  ))

  (mjs-leader-def :states '(normal insert) :keymaps 'org-mode-map
    "f M" '("Move File & Update Links" . mjs/move-and-update-file-links))
#+end_src


*** Transclusions

A transclusion is when instead of just having a link, we display the contents of
that link as well. This is a very powerful feature that I only used occasionally
in Obsidian, but since I have the option of using that same feature via
=org-transclusions=, I might as well use it!

#+begin_src emacs-lisp
  (use-package org-transclusion
    :after org
    :general (mjs-local-leader-def :states 'normal :keymaps 'org-mode-map
               "u" '(nil :which-key "Transclusions")
               "u a" '("Add Transclusion" . org-transclusion-add)
               "u u" '("Activate All Transclusions" . org-transclusion-mode)
               "u r" '("Remove Transclusion" . org-transclusion-remove))
#+end_src

*** Media Handling

Try =org-cliplink= which might make inserting links for Pathfinder stat blocks
easier.

#+begin_src emacs-lisp :tangle init.el
  (use-package org-cliplink
    :general (mjs-local-leader-def :states 'normal :keymaps 'org-mode-map
               "l c" '("Paste URL" . mjs/clean-org-cliplink)
               "l C" '("Paste Raw URL" . org-cliplink))
    :init (defun mjs/clean-org-cliplink ()
            (interactive)
            (org-cliplink-insert-transformed-title
            (org-cliplink-clipboard-content)     ;take the URL from the CLIPBOARD
            (lambda (url title)
                (let* ((parsed-url (url-generic-parse-url url)) ;parse the url
                  (clean-title
                    (cond
                    ;; if the host is aonprd.com, cleanup the title
                    ((string= (url-host parsed-url) "aonprd.com")
                      (replace-regexp-in-string " - .*" "" title))
                    ;; otherwise keep the original title
                    (t title))))
            ;; forward the title to the default org-cliplink transformer
            (org-cliplink-org-mode-link-transformer url clean-title))))))
#+end_src

*** Org Chef!

On my personal website (=schwennesen.org=), I maintain a collection of recipes. In
order to help with that, I'd like to try out =org-chef=.

#+begin_src emacs-lisp :tangle init.el
  (use-package org-chef
    :config (add-to-list 'org-capture-templates
                         `("r" "Recipe" entry
                           (file ,(concat org-directory "recipes.org"))
                           "%(org-chef-get-recipe-from-url)"
                           :empty-lines 1) t)
            (add-to-list 'org-capture-templates
                         `("R" "Manual Recipe" entry
                           (file ,(concat org-directory "recipes.org"))
                           ,(concat "* %^{Recipe title: }\n"
                                    "  :PROPERTIES:\n"
                                    "  :source-url:\n"
                                    "  :servings:\n"
                                    "  :prep-time:\n"
                                    "  :cook-time:\n"
                                    "  :ready-in:\n"
                                    "  :END:\n\n"
                                    "** Ingredients\n\n"
                                    "   %?\n\n"
                                    "** Directions\n\n")) t))
#+end_src

*** Exporting Org Documents

There are two additional ways I may want to export =org= documents, using =pandoc=
or to =hugo= markdown to publish on a website.

#+begin_src emacs-lisp :tangle init.el
  (use-package ox-pandoc
    :after ox
    :general (mjs-local-leader-def :states '(normal insert)
               :keymap 'org-mode-map
               "e" '(nil :which-key "Export")
               "e e" '("Export Dispatcher" . org-export-dispatch) 
               "e l" '(nil :which-key "LaTeX")
               "e l b" '("Pandoc LaTeX Buffer" . org-pandoc-export-as-latex)
               "e l l" '("LaTeX File" . org-latex-export-to-pdf)
               "e l f" '("Pandoc LaTeX File" . org-pandoc-export-to-latex)
               "e l o" '("Pandoc LaTeX Open File" . org-pandoc-export-to-latex-and-open)
               "e l p" '("Pandoc LaTeX PDF" . org-pandoc-export-to-latex-pdf)
               "e l P" '("Pandoc LaTeX Open PDF" . org-pandoc-to-latex-pdf-and-open)
               "e H" '(nil :which-key "HTML")
               "e H b" '("HTML5 Buffer" . org-pandoc-export-as-html5)
               "e H B" '("HTML4 Buffer" . org-pandoc-export-as-html4)
               "e H f" '("HTML5 File" . org-pandoc-export-to-html5)
               "e H F" '("HTML4 File" . org-pandoc-export-to-html4)
               "e H o" '("Open HTML5 File" . org-pandoc-export-to-html5-and-open)
               "e H O" '("Open HTML4 File" . org-pandoc-export-to-html4-and-open)
               "e M" '(nil :which-key "Man")
               "e M b" '("Man Buffer" . org-pandoc-export-as-man)
               "e M f" '("Man File" . org-pandoc-export-to-man)
               "e M o" '("Open Man File" . org-pandoc-export-to-man-and-open)
               "e m" '(nil :which-key "Markdown")
               "e m b" '("Markdown Buffer" . org-pandoc-export-as-markdown)
               "e m f" '("Markdown File" . org-pandoc-export-to-markdown)
               "e m o" '("Open Markdown File" . org-pandoc-export-to-markdown-and-open)
               "e w" '(nil :which-key "MediaWiki")
               "e w b" '("MediaWiki Buffer" . org-pandoc-export-as-mediawiki)
               "e w f" '("MediaWiki File" . org-pandoc-export-to-mediawiki)
               "e w o" '("Open MediaWiki File" . org-pandoc-export-to-mediawiki-and-open)))

  (use-package ox-hugo
    :after ox
    :general (mjs-local-leader-def :states '(normal insert)
               :keymaps 'org-mode-map
               "e h" '(nil :which-key "Hugo")
               "e h d" '("DWIM" . org-hugo-export-wim-to-md)
               "e h a" '("All Subtrees" . (lambda () (org-hugo-wim-to-md t)))
               "e h o" '("File" . org-hugo-export-to-md)))
#+end_src

*** Presentation

Yes, you can give presentations directly from Emacs using =org-tree-slide=!

#+begin_src emacs-lisp :tangle init.el
  (use-package org-tree-slide
    :commands org-tree-slide-mode
    :diminish " 󰐨"
    :general (mjs-local-leader-def :states '(normal insert)
               :keymaps 'org-mode-map
                      "p" '("Present" . org-tree-slide-mode))
             (:states '(normal insert) :keymaps 'org-tree-slide-mode-map
                      "C-<right>" #'org-tree-slide-move-next-tree
                      "C-<left>" #'org-tree-slide-move-previous-tree)
    :custom (org-tree-slide-activate-message " ")
            (org-tree-slide-deactivate-message " ")
            (org-tree-slide-modeline-display nil)
            (org-tree-slide-heading-emphasis t)
    :config (org-tree-slide-simple-profile)
            (add-hook 'org-tree-slide-play-hook
                      (lambda ()
                        (text-scale-set 4)))
            (add-hook 'org-tree-slide-stop-hook
                      (lambda ()
                        (text-scale-mode -1))))
#+end_src

# Local Variables:
# jinx-local-words: "Catppuccin Flycheck neovim"
# End:

